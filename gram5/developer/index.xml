<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<book lang="en">
<bookinfo>
    <title>GT 6.0 GRAM5: Developer&#8217;s Guide</title>
</bookinfo>
<preface>
<title></title>
<simpara>This guide is intended to help a developer interact with GRAM5. It
includes sections on implementing clients in C and implementing a Local
Resource Manager interface, as well as an overview of concepts and APIs
used to interact with GRAM.</simpara>
</preface>
<part id="_introduction">
<title>Introduction</title>
<chapter id="gram5-developer-beforeyoubegin">
<title>Before you begin</title>
<section id="gram5-features">
<title>Feature summary</title>
<simpara>New Features new since 5.2:</simpara>
<itemizedlist>
<listitem>
<simpara>
Bug fixes and improved testing
</simpara>
</listitem>
</itemizedlist>
<simpara>Other Standard Supported Features</simpara>
<itemizedlist>
<listitem>
<simpara>
Remote job execution and management
</simpara>
</listitem>
<listitem>
<simpara>
Uniform and flexible interface to local resource managers, including Condor, LSF, and SLURM, and GridEngine
</simpara>
</listitem>
<listitem>
<simpara>
File staging before and after job execution
</simpara>
</listitem>
<listitem>
<simpara>
File and directory clean up after job termination
</simpara>
</listitem>
<listitem>
<simpara>
Service auditing for each submitted
</simpara>
</listitem>
</itemizedlist>
<simpara>Removed Features</simpara>
<itemizedlist>
<listitem>
<simpara>
None.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="gram5-platforms">
<title>Tested platforms</title>
<simpara>GRAM5 has been tested extensively on the following platforms:</simpara>
<table id="tested-platforms"
frame="all"
rowsep="1" colsep="1"
>
<title>Tested Platforms</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top"> Operating System </entry>
<entry align="left" valign="top"> Distribution </entry>
<entry align="left" valign="top"> Version(s) </entry>
<entry align="left" valign="top"> Architecture(s)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="9"><simpara>Linux</simpara></entry>
<entry align="left" valign="top" morerows="1"><simpara>CentOS</simpara></entry>
<entry align="left" valign="top"><simpara>5, 6</simpara></entry>
<entry align="left" valign="top"><simpara>i386, x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Fedora</simpara></entry>
<entry align="left" valign="top"><simpara>20, 21, 22</simpara></entry>
<entry align="left" valign="top"><simpara>i386, x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>Red Hat Enterprise Linux</simpara></entry>
<entry align="left" valign="top"><simpara>5, 6</simpara></entry>
<entry align="left" valign="top"><simpara>i386, x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>Scientific Linux</simpara></entry>
<entry align="left" valign="top"><simpara>5, 6</simpara></entry>
<entry align="left" valign="top"><simpara>i386, x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>SUSE Linux Enterprise Server</simpara></entry>
<entry align="left" valign="top"><simpara>11SP3</simpara></entry>
<entry align="left" valign="top"><simpara>x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Debian</simpara></entry>
<entry align="left" valign="top"><simpara>6, 7, 8</simpara></entry>
<entry align="left" valign="top"><simpara>i386, amd64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ubuntu</simpara></entry>
<entry align="left" valign="top"><simpara>12.04LTS, 14.04LTS, 14.10, 15.04</simpara></entry>
<entry align="left" valign="top"><simpara>i386, amd64</simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_2"><simpara>Mac OS X</simpara></entry>
<entry align="left" valign="top"><simpara>10.6-10.10</simpara></entry>
<entry align="left" valign="top"><simpara>i386, x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Solaris</simpara></entry>
<entry align="left" valign="top"><simpara>OmniOS</simpara></entry>
<entry align="left" valign="top"><simpara>r151006</simpara></entry>
<entry align="left" valign="top"><simpara>x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top" morerows="1"><simpara>Windows 7</simpara></entry>
<entry align="left" valign="top" namest="col_2" nameend="col_3"><simpara>Cygwin</simpara></entry>
<entry align="left" valign="top"><simpara>i386, x86_64</simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_2" nameend="col_3"><simpara>MingW64</simpara></entry>
<entry align="left" valign="top"><simpara>i386, x86_64</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section id="gram5-compatibility">
<title>Backward compatibility summary</title>
<simpara>Protocol changes in GRAM since GT4 series:</simpara>
<itemizedlist>
<listitem>
<simpara>
The GRAM5 service uses a superset of the GRAM2 protocol for communciation between the client and service. The extensions supported in GRAM5 are implemented in such a way that they are ignored by GRAM2 services or clients. These extensions provide improved error messages and version detection.
</simpara>
</listitem>
<listitem>
<simpara>
GRAM5 does not support task coallocation using DUROC and its related protocols. Jobs submitted using DUROC directives will fail.
</simpara>
</listitem>
<listitem>
<simpara>
GRAM5 does not support file streaming. The standard output and standard error streams are sent after the job completes instead of during execution. As a special case, support for the Condor grid monitor program implements a small subset of the streaming capabilities of GRAM2 in GT 4.2.x.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="gram5-dependencies">
<title>Technology dependencies</title>
<simpara>GRAM depends on the following GT components:</simpara>
<itemizedlist>
<listitem>
<simpara>
Globus Common
</simpara>
</listitem>
<listitem>
<simpara>
GSI C
</simpara>
</listitem>
<listitem>
<simpara>
GridFTP server
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="gram5-security-considerations">
<title>Security Considerations</title>
<section id="_gatekeeper_security_considerations">
<title>Gatekeeper Security Considerations</title>
<simpara>GRAM5 runs different parts of itself under different privilege levels.
The <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> runs as root, and uses its root privilege
to access the host&#8217;s private key. It uses the grid map file to map Grid
Certificates to local user ids and then uses the <emphasis role="strong"><literal>setuid()</literal></emphasis>
function to change to that user and execute the
<emphasis role="strong"><literal>globus-job-manager</literal></emphasis> program</simpara>
</section>
<section id="_job_manager_security_considerations">
<title>Job Manager Security Considerations</title>
<simpara>The <emphasis role="strong"><literal>globus-job-manager</literal></emphasis> program runs as a local non-root account.
It receives a delegated limited proxy certificate from the GRAM5 client
which it uses to access Grid storage resources via GridFTP and to
authenticate job signals (such as client cancel requests), and send job
state callbacks to registered clients. This proxy is generally
short-lived, and is automatically removed by the job manager when the
job completes.</simpara>
<simpara>The <emphasis role="strong"><literal>globus-job-manager</literal></emphasis> program uses a publicly-writable
directory for job state files. This directory has the <emphasis role="strong">sticky</emphasis> bit
set, so users may not remove other users files. Each file is named by a
UUID, so it should be unique.</simpara>
</section>
<section id="_fork_seg_module_security_considerations">
<title>Fork SEG Module Security Considerations</title>
<simpara>The Fork Scheduler Event Generator module uses a globally writable file
for job state change events. This is not recommended for production use.</simpara>
</section>
</section>
</chapter>
<chapter id="gram5-developer-concepts">
<title>GRAM5 Concepts for Developers</title>
<section id="gram5-developer-concepts-blocking">
<title>Blocking and Nonblocking Function Variants</title>
<simpara>In the GRAM Client API, all functions that involve sending messages over
the network have both blocking and nonblocking variants. These are
useful in different programming situations.</simpara>
<simpara>The blocking variants, such as the
<emphasis role="strong"><literal>globus_gram_client_job_request</literal></emphasis> function require less application
code, but will prevent subsequent instructions from executing until the
request has been sent and the reply parsed. In a non-threaded
environment, other callback functions registered with the Globus event
driver may be invoked while the blocking function is running. In a
threaded environment, other events may occur in other threads while the
function is blocking, but the current thread will be blocked until the
response is parsed.</simpara>
<simpara>The nonblocking variants, such as
<emphasis role="strong"><literal>globus_gram_client_register_job_request</literal></emphasis> require the application
to include a callback function which will be called by the Globus event
driver when the reply has been parsed. In a non-threaded environment,
applications must poll the event driver using functions from the
<emphasis role="strong"><literal>globus_poll</literal></emphasis> or <emphasis role="strong"><literal>globus_cond_wait</literal></emphasis> families of functions.
In a threaded environment, the callback function may be invoked in
another thread than the one calling the non-blocking function, even
before the non-blocking function has returned. Application writers must
be careful in using synchronization primitives such as
<emphasis role="strong"><literal>globus_mutex_t</literal></emphasis> and <emphasis role="strong"><literal>globus_cond_t</literal></emphasis> when using non-blocking
functions.</simpara>
<simpara>An application writer should use the non-blocking variants if the
application will be submitting many jobs concurrently or requires custom
network or security attributes. Using the non-blocking variants allows
the Globus event driver to better schedule network I/O in these cases.</simpara>
</section>
<section id="_service_contact_strings">
<title>Service Contact Strings</title>
<simpara>GRAM uses three types of <emphasis role="strong">contact strings</emphasis> to describe how to contact
different services. These service contacts are:</simpara>
<table
frame="all"
rowsep="1" colsep="1"
>
<title>GRAM Contact String Types</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"> Type </entry>
<entry align="left" valign="top"> Meaning </entry>
<entry align="left" valign="top"> Gatekeeper Service Contact</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>This string describes how to contact a
gatekeeper service. It is used to submit jobs, send
"ping" requests to determine if a service is properly
deployed, and version requests to determine what
version of the software is deployed. Full details of
the syntax of this contact is located in the next
section.</simpara></entry>
<entry align="left" valign="top"><simpara>Callback Contact</simpara></entry>
<entry align="left" valign="top"><simpara>This string is an HTTPS URL that
is an endpoint for GRAM job state callbacks. An https
message is posted to this address when the Job Manager
detects a job state change.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<section id="gram5-developer-resource-names">
<title>Resource Names</title>
<simpara>In GRAM5, a Gatekeeper Service Contact contains the host, port, service
name, and service identity required to contact a particular GRAM
service. For convenience, default values are used when parts of the
contact are omitted. An example of a full gatekeeper service contact is
<literal>grid.example.org:2119/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</literal>.</simpara>
<simpara>The various forms of the resource name using default values follow:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis>HOST</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>:</literal><emphasis>PORT</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>:</literal><emphasis>PORT</emphasis><literal>/</literal><emphasis>SERVICE</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>/</literal><emphasis>SERVICE</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>:/</literal><emphasis>SERVICE</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>:</literal><emphasis>PORT</emphasis><literal>:</literal><emphasis>SUBJECT</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>/</literal><emphasis>SERVICE</emphasis><literal>:</literal><emphasis>SUBJECT</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>:/</literal><emphasis>SERVICE</emphasis><literal>:</literal><emphasis>SUBJECT</emphasis>
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis>HOST</emphasis><literal>:</literal><emphasis>PORT</emphasis><literal>/</literal><emphasis>SERVICE</emphasis><literal>:</literal><emphasis>SUBJECT</emphasis>
</simpara>
</listitem>
</itemizedlist>
<simpara>Where the various values have the following meaning:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>HOST</emphasis></emphasis>
</term>
<listitem>
<simpara>
     Network name of the machine hosting the service.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>PORT</emphasis></emphasis>
</term>
<listitem>
<simpara>
     Network port number that the service is listening on. If not specified, the default of <literal>2119</literal> is used.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>SERVICE</emphasis></emphasis>
</term>
<listitem>
<simpara>
     Path of the service entry in <literal>$GLOBUS_LOCATION/etc/grid-services</literal>. If not specified, the default of . If not specified, the default of <literal>jobmanager</literal> is used.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>SUBJECT</emphasis></emphasis>
</term>
<listitem>
<simpara>
     X.509 identity of the credential used by the service. If not specified, the default of <literal>host@</literal><emphasis>HOST</emphasis> is used.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<example>
<title>Gatekeeper Service Contact Examples</title>
<simpara>The following strings all name the service
<literal>grid.example.org:2119/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</literal>
using the formats with the various defaults described above.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>grid.example.org</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org:2119</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org:2119/jobmanager</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org/jobmanager</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org:/jobmanager</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org:2119:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org:/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</literal>
</simpara>
</listitem>
<listitem>
<simpara>
<literal>grid.example.org:2119/jobmanager:/C=US/O=Example/OU=Grid/CN=host/grid.example.org</literal>
</simpara>
</listitem>
</itemizedlist>
</example>
</section>
</section>
<section id="gram5-developer-jobstatecallbacks">
<title>Job State Callbacks and Polling</title>
<simpara>GRAM clients and learn about a job&#8217;s state in two ways: by registering
for job state callbacks and by polling for status. These two methods
have different performance characteristics and costs.</simpara>
<simpara>In order to receive job state callbacks, a client application must
create an HTTPS listener using the
<emphasis role="strong"><literal>globus_gram_client_callback_allow</literal></emphasis> or
<emphasis role="strong"><literal>globus_gram_client_info_callback_allow</literal></emphasis> functions. A non-threaded
application must then periodically call a function from either the
<emphasis role="strong"><literal>globus_cond_wait</literal></emphasis> or <emphasis role="strong"><literal>globus_poll</literal></emphasis> families in order to
process the job state callbacks. Additionally, the network must be
configured to allow the GRAM job manager to send messages to the port
that the client is listening on. This may be difficult if there is a
firewall between the client and service.</simpara>
<simpara>The GRAM service initiates the job state callbacks, and thus they are
usually sent very shortly after the job state changes, so clients can be
notified about the state changes quickly.</simpara>
<simpara>In order to poll for job states, a client can call either the blocking
or nonblocking variant of the <emphasis role="strong"><literal>globus_gram_client_job_status</literal></emphasis> or
<emphasis role="strong"><literal>globus_gram_client_job_status_with_info</literal></emphasis> functions. These
functions require that the network be configured to allow the client to
contact the network port that the GRAM service is listening on (the Job
Contact).</simpara>
<simpara>The client intiates these polling operations, so they are only as
accurate as the polling frequence of the client. If the client polls
very often, it will receive job state changes more quickly, at the risk
of increasing the computing and network cost of both the client and
service.</simpara>
</section>
<section id="_credential_management">
<title>Credential Management</title>
<simpara>The GRAM5 protocols all use GSSAPIv2 abstractions to provide
authentication and authorization. By default, GRAM uses an SSL-based
GSSAPI for its security.</simpara>
<simpara>The client delegates a credential to the gatekeeper service after
authentication, and the GRAM job manager service uses this delegated
credential as both a job-specific credential and for subsequent
communication with GRAM clients.</simpara>
<simpara>If a client or clients submit multiple jobs to a gatekeeper service,
they will eventually all be handled by a single job manager process.
This process will use whichever delegated credential will remain valid
the longest for accepting new connections and connecting to clients to
send job state callbacks. When a client delegates a new credential to a
job, this credential may also be used as the job manager&#8217;s credential
for future connections.</simpara>
</section>
<section id="_rsl">
<title>RSL</title>
<simpara>GRAM5 jobs are described using the RSL language. The GRAM client API
submits jobs using the string representation of the RSL, rather than the
RSL parse tree. Clients can, if they need to modify of construct RSL at
runtime, use the functions in the RSL API to do so.</simpara>
</section>
</chapter>
</part>
<part id="_gram_client_developer_8217_s_guide">
<title>GRAM Client Developer&#8217;s Guide</title>
<chapter id="gram5-developer-scenarios">
<title>Basic GRAM Client Scenarios</title>
<simpara>This chapter contains a series of examples demonstrating how to use
different features of the GRAM APIs to interact with the GRAM service.
These examples can be compiled by using GNU make with the makefile from
<ulink url="Makefile.examples">Makefile.examples</ulink>.</simpara>
<section id="_ping_a_job_manager">
<title>"Ping" a Job Manager</title>
<simpara>This example shows how to use a gatekeeper "ping" request to determine
if a service is running and if the client is authorized to contact it.
It takes a gatekeeper service contact as its only command-line option.
The <ulink url="gram_ping_example.c">source to this example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Pinging GRAM resource: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Ping the service passed as our first command-line option. If successful,
     * this function will return GLOBUS_SUCCESS, otherwise an integer
     * error code.
     */
    rc = globus_gram_client_ping(argv[1]);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to ping service at %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        printf("Ping successful\n");
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_ping_example.c */</screen>
</section>
<section id="_check_a_job_manager_version">
<title>Check a Job Manager Version</title>
<simpara>This example shows how to use the "version" command to determine what
software version a gatekeeper service is running. The
<ulink url="gram_version_example.c">source to this example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"
#include "globus_gram_protocol.h"

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int
main(int argc, char *argv[])
{
    int rc;
    globus_hashtable_t extensions = NULL;
    globus_gram_protocol_extension_t * extension_value;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Checking version of GRAM resource: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Contact the service passed as our first command-line option and perform
     * a version check. If successful,
     * this function will return GLOBUS_SUCCESS, otherwise an integer
     * error code. Old versions of the job manager will return
     * GLOBUS_GRAM_PROTOCOL_ERROR_HTTP_UNPACK_FAILED as they do not support
     * the version operation.
     */
    rc = globus_gram_client_get_jobmanager_version(argv[1], &amp;extensions);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to get service version from %s because %s "
                "(Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        /* The version information is returned in the extensions hash table */
        extension_value = globus_hashtable_lookup(
                &amp;extensions,
                "toolkit-version");

        if (extension_value == NULL)
        {
            printf("Unknown toolkit version\n");
        }
        else
        {
            printf("Toolkit Version: %s\n", extension_value-&gt;value);
        }

        extension_value = globus_hashtable_lookup(
                &amp;extensions,
                "version");
        if (extension_value == NULL)
        {
            printf("Unknown package version\n");
        }
        else
        {
            printf("Package Version: %s\n", extension_value-&gt;value);
        }
        /* Free the extensions hash and its values */
        globus_gram_protocol_hash_destroy(&amp;extensions);
    }

    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_version_example.c */</screen>
</section>
<section id="_submitting_a_job">
<title>Submitting a Job</title>
<simpara>This example shows how to submit a job to a GRAM service. The
<ulink url="gram_submit_example.c">source to this example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;
    char * job_contact = NULL;

    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Submitting job to GRAM resource: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Submit the job request to the service passed as our first command-line
     * option. If successful, this function will return GLOBUS_SUCCESS,
     * otherwise an integer error code.
     */
    rc = globus_gram_client_job_request(
            argv[1], argv[2], 0, NULL, &amp;job_contact);

    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job to %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
        if (job_contact != NULL)
        {
            printf("Job Contact: %s\n", job_contact);
        }
    }
    else
    {
        /* Display job contact string */
        printf("Job submit successful: %s\n", job_contact);
    }

    if (job_contact != NULL)
    {
        free(job_contact);
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_submit_example.c */</screen>
</section>
<section id="_submitting_a_job_and_processing_job_state_callbacks">
<title>Submitting a Job and Processing Job State Callbacks</title>
<simpara>This example shows how to submit a job to a GRAM service and then wait
until the job reaches the FAILED or DONE state. The
<ulink url="gram_submit_and_wait_example.c">source to this example</ulink> can be
downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

struct monitor_t
{
    globus_mutex_t mutex;
    globus_cond_t cond;
    globus_gram_protocol_job_state_t state;
};

/*
 * Job State Callback Function
 *
 * This function is called when the job manager sends job states.
 */
static
void
example_callback(void * callback_arg, char * job_contact, int state,
        int errorcode)
{
    struct monitor_t * monitor = callback_arg;

    globus_mutex_lock(&amp;monitor-&gt;mutex);

    printf("Old Job State: %d\nNew Job State: %d\n", monitor-&gt;state, state);

    monitor-&gt;state = state;

    if (state == GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED ||
        state == GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE)
    {
        globus_cond_signal(&amp;monitor-&gt;cond);
    }
    globus_mutex_unlock(&amp;monitor-&gt;mutex);
}

int
main(int argc, char *argv[])
{
    int rc;
    char * callback_contact = NULL;
    char * job_contact = NULL;
    struct monitor_t monitor;

    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    rc = globus_mutex_init(&amp;monitor.mutex, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing mutex\n");
        goto deactivate;
    }
    rc = globus_cond_init(&amp;monitor.cond, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing condition variable\n");
        goto destroy_mutex;
    }

    monitor.state = GLOBUS_GRAM_PROTOCOL_JOB_STATE_UNSUBMITTED;

    globus_mutex_lock(&amp;monitor.mutex);

    /*
     * Allow GRAM state change callbacks
     */
    rc = globus_gram_client_callback_allow(
            example_callback, &amp;monitor, &amp;callback_contact);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error allowing callbacks because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
        goto destroy_cond;
    }
    /*
     * Submit the job request to the service passed as our first command-line
     * option.
     */
    rc = globus_gram_client_job_request(
            argv[1], argv[2],
            GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED|
            GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE,
            callback_contact, &amp;job_contact);

    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job to %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
        /* Job submit failed. Short circuit the while loop below by setting
         * the job state to failed
         */
        monitor.state = GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED;
    }
    else
    {
        /* Display job contact string */
        printf("Job submit successful: %s\n", job_contact);
    }

    /* Wait for job state callback to let us know the job has completed */
    while (monitor.state != GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE &amp;&amp;
           monitor.state != GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED)
    {
        globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
    }
    rc = globus_gram_client_callback_disallow(callback_contact);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error disabling callbacks because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
    }
    globus_mutex_unlock(&amp;monitor.mutex);

    if (job_contact != NULL)
    {
        free(job_contact);
    }

destroy_cond:
    globus_cond_destroy(&amp;monitor.cond);
destroy_mutex:
    globus_mutex_destroy(&amp;monitor.mutex);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_submit_and_wait_example.c */</screen>
</section>
<section id="_polling_job_status">
<title>Polling Job Status</title>
<simpara>This example shows how to submit a job to a GRAM service and then wait
until the job reaches the FAILED or DONE state. The
<ulink url="gram_poll_example.c">source to this example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;
    int status = 0;
    int failure_code = 0;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s JOB-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Check the job status of the job named by the first argument to
     * this program.
     */
    rc = globus_gram_client_job_status(argv[1], &amp;status, &amp;failure_code);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to check job status because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
    }
    else
    {
        switch (status)
        {
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_UNSUBMITTED:
                printf("Unsubmitted\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_IN:
                printf("StageIn\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING:
                printf("Pending\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_ACTIVE:
                printf("Active\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_SUSPENDED:
                printf("Suspended\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_OUT:
                printf("StageOut\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE:
                printf("Done\n");
                break;
            case GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED:
                printf("Failed (%d)\n", failure_code);
                break;
            default:
                printf("Unknown job state\n");
                break;
        }
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_poll_example.c */</screen>
</section>
<section id="_canceling_a_job">
<title>Canceling a Job</title>
<simpara>This example shows how to cancel a job being run by a GRAM service. The
<ulink url="gram_cancel_example.c">source to this example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s JOB-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Cancel the job named by the first argument to
     * this program.
     */
    rc = globus_gram_client_job_cancel(argv[1]);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to cancel job because %s (Error %d)\n",
                globus_gram_client_error_string(rc), rc);
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_cancel_example.c */</screen>
</section>
<section id="_refreshing_job_credential">
<title>Refreshing Job Credential</title>
<simpara>This example shows how to refresh a GRAM job&#8217;s credential after the job
has been submitted by some other means. The
<ulink url="gram_refresh_example.c">source to this example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

int
main(int argc, char *argv[])
{
    int rc;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %s JOB-CONTACT\n", argv[0]);
        rc = 1;

        goto out;
    }

    printf("Refreshing Credential for GRAM Job: %s\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }
    /*
     * Refresh the credential of the job running at the contact named
     * by the first command-line argument to this program. We'll use the
     * process's default credential by passing in GSS_C_NO_CREDENTIAL.
     */
    rc = globus_gram_client_job_refresh_credentials(
            argv[1], GSS_C_NO_CREDENTIAL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to refresh credential for job %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        printf("Refresh successful\n");
    }
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_refresh_example.c */</screen>
</section>
</chapter>
<chapter id="gram5-developer-scenarios-advanced">
<title>Advanced GRAM Client Scenarios</title>
<section id="_non_blocking_job_submission">
<title>Non-blocking Job Submission</title>
<simpara>This example shows how to submit a series of GRAM jobs using the
non-blocking function <emphasis role="strong"><literal>globus_gram_client_register_job_request</literal></emphasis>
and wait until all submissions have completed. This example throttles
the number of concurrent job submissions to reduce the load on the
service node. The <ulink url="gram_nonblocking_submit_example.c">source to this
example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

struct monitor_t
{
    globus_mutex_t mutex;
    globus_cond_t cond;
    int submit_pending;
    int successful_submits;
};

#define CONCURRENT_SUBMITS 5

static
void
example_submit_callback(
    void * user_callback_arg,
    globus_gram_protocol_error_t operation_failure_code,
    const char * job_contact,
    globus_gram_protocol_job_state_t job_state,
    globus_gram_protocol_error_t job_failure_code)
{
    struct monitor_t * monitor = user_callback_arg;

    globus_mutex_lock(&amp;monitor-&gt;mutex);
    monitor-&gt;submit_pending--;
    if (monitor-&gt;submit_pending &lt; CONCURRENT_SUBMITS)
    {
        globus_cond_signal(&amp;monitor-&gt;cond);
    }
    printf("Submitted job %s\n",
            job_contact ? job_contact : "UNKNOWN");
    if (operation_failure_code == GLOBUS_SUCCESS)
    {
        monitor-&gt;successful_submits++;
    }
    else
    {
        printf("submit failed because %s (Error %d)\n",
                globus_gram_client_error_string(operation_failure_code),
                operation_failure_code);
    }
    globus_mutex_unlock(&amp;monitor-&gt;mutex);
}

int
main(int argc, char *argv[])
{
    int rc;
    int i;
    struct monitor_t monitor;

    if (argc &lt; 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL-SPEC...\n",
                argv[0]);
        rc = 1;

        goto out;
    }

    printf("Submiting %d jobs to %s\n", argc-2, argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    rc = globus_mutex_init(&amp;monitor.mutex, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing mutex %d\n", rc);

        goto deactivate;
    }

    rc = globus_cond_init(&amp;monitor.cond, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing condition variable %d\n", rc);

        goto destroy_mutex;
    }
    monitor.submit_pending = 0;

    /* Submits jobs from argv[2] until end of the argv array. At most
     * CONCURRENT_SUBMITS will be pending at any given time.
     */
    globus_mutex_lock(&amp;monitor.mutex);
    for (i = 2; i &lt; argc; i++)
    {
        /* This throttles the number of concurrent job submissions */
        while (monitor.submit_pending &gt;= CONCURRENT_SUBMITS)
        {
            globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
        }

        /* When the job has been submitted, the example_submit_callback
         * will be called, either from another thread or from a
         * globus_cond_wait in a nonthreaded build
         */
        rc = globus_gram_client_register_job_request(
                argv[1], argv[i], 0, NULL, NULL, example_submit_callback,
                &amp;monitor);
        if (rc != GLOBUS_SUCCESS)
        {
            fprintf(stderr, "Unable to submit job %s because %s (Error %d)\n",
                    argv[i], globus_gram_client_error_string(rc), rc);
        }
        else
        {
            monitor.submit_pending++;
        }
    }

    /* Wait until the example_submit_callback function has been called for
     * each job submission
     */
    while (monitor.submit_pending &gt; 0)
    {
        globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
    }
    globus_mutex_unlock(&amp;monitor.mutex);

    printf("Submitted %d jobs (%d successfully)\n",
            argc-2, monitor.successful_submits);

    globus_cond_destroy(&amp;monitor.cond);
destroy_mutex:
    globus_mutex_destroy(&amp;monitor.mutex);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_nonblocking_submit_example.c */</screen>
</section>
<section id="_custom_security_attributes">
<title>Custom Security Attributes</title>
<simpara>This example shows how to submit a job and delegate a full credential to
the job. The <ulink url="gram_attr_example.c">source to this example</ulink> can be
downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module functions
 * and GRAM Client API functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"

#include &lt;stdio.h&gt;

struct monitor_t
{
    globus_mutex_t mutex;
    globus_cond_t cond;
    globus_bool_t done;
};

static
void
example_submit_callback(
    void * user_callback_arg,
    globus_gram_protocol_error_t operation_failure_code,
    const char * job_contact,
    globus_gram_protocol_job_state_t job_state,
    globus_gram_protocol_error_t job_failure_code)
{
    struct monitor_t * monitor = user_callback_arg;

    globus_mutex_lock(&amp;monitor-&gt;mutex);
    monitor-&gt;done = GLOBUS_TRUE;
    globus_cond_signal(&amp;monitor-&gt;cond);
    if (operation_failure_code == GLOBUS_SUCCESS)
    {
        printf("Submitted job %s\n",
            job_contact ? job_contact : "UNKNOWN");
    }
    else
    {
        printf("submit failed because %s (Error %d)\n",
                globus_gram_client_error_string(operation_failure_code),
                operation_failure_code);
    }
    globus_mutex_unlock(&amp;monitor-&gt;mutex);
}

int
main(int argc, char *argv[])
{
    int rc;
    globus_gram_client_attr_t attr;
    struct monitor_t monitor;

    if (argc &lt; 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL-SPEC...\n",
                argv[0]);
        rc = 1;

        goto out;
    }

    printf("Submiting job to %s with full proxy\n", argv[1]);

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    rc = globus_mutex_init(&amp;monitor.mutex, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing mutex %d\n", rc);

        goto deactivate;
    }

    rc = globus_cond_init(&amp;monitor.cond, NULL);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error initializing condition variable %d\n", rc);

        goto destroy_mutex;
    }
    monitor.done = GLOBUS_FALSE;

    /* Initialize attribute so that we can set the delegation attribute */
    rc = globus_gram_client_attr_init(&amp;attr);

    /* Set the proxy attribute */
    rc = globus_gram_client_attr_set_delegation_mode(
        attr,
        GLOBUS_IO_SECURE_DELEGATION_MODE_FULL_PROXY);

    /* Submit the job rsl from argv[2]
     */
    globus_mutex_lock(&amp;monitor.mutex);
    /* When the job has been submitted, the example_submit_callback
     * will be called, either from another thread or from a
     * globus_cond_wait in a nonthreaded build
     */
    rc = globus_gram_client_register_job_request(
            argv[1], argv[2], 0, NULL, attr, example_submit_callback,
            &amp;monitor);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job %s because %s (Error %d)\n",
                argv[2], globus_gram_client_error_string(rc), rc);
    }

    /* Wait until the example_submit_callback function has been called for
     * the job submission
     */
    while (!monitor.done)
    {
        globus_cond_wait(&amp;monitor.cond, &amp;monitor.mutex);
    }
    globus_mutex_unlock(&amp;monitor.mutex);

    globus_cond_destroy(&amp;monitor.cond);
destroy_mutex:
    globus_mutex_destroy(&amp;monitor.mutex);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_attr_example.c */</screen>
</section>
<section id="_modifying_rsl">
<title>Modifying RSL</title>
<simpara>This example shows how to programmatically add environment variable
definitions to an RSL prior to submitting a job. The
<ulink url="gram_rsl_example.c">source to this example</ulink> can be downloaded.</simpara>
<screen>/*
 * These headers contain declarations for the globus_module,
 * the GRAM Client, RSL, and protocol functions
 */
#include "globus_common.h"
#include "globus_gram_client.h"
#include "globus_rsl.h"
#include "globus_gram_protocol.h"

#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;

static
int
example_rsl_attribute_match(void * datum, void * arg)
{
    const char * relation_attribute = globus_rsl_relation_get_attribute(datum);
    const char * attribute = arg;

    /* RSL attributes are case-insensitive */
    return (relation_attribute &amp;&amp;
            strcasecmp(relation_attribute, attribute) == 0);
}

int
main(int argc, char *argv[])
{
    int rc;
    globus_rsl_t *rsl, *environment_relation;
    globus_rsl_value_t *new_env_pair = NULL;
    globus_list_t *environment_relation_node;
    char * rsl_string;
    char * job_contact;

    if (argc != 3)
    {
        fprintf(stderr, "Usage: %s RESOURCE-MANAGER-CONTACT RSL\n", argv[0]);
        rc = 1;

        goto out;
    }

    /*
     * Always activate the GLOBUS_GRAM_CLIENT_MODULE prior to using any
     * functions from the GRAM Client API or behavior is undefined.
     */
    rc = globus_module_activate(GLOBUS_GRAM_CLIENT_MODULE);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Error activating %s because %s (Error %d)\n",
                GLOBUS_GRAM_CLIENT_MODULE-&gt;module_name,
                globus_gram_client_error_string(rc),
                rc);
        goto out;
    }

    /* Parse the RSL string into a syntax tree */
    rsl = globus_rsl_parse(argv[2]);
    if (rsl == NULL)
    {
        rc = 1;
        fprintf(stderr, "Error parsing RSL string\n");
        goto deactivate;
    }

    /* Create the new environment variable pair that we'll insert
     * into the RSL. We'll start by making an empty sequence
     */
    new_env_pair = globus_rsl_value_make_sequence(NULL);
    if (new_env_pair == NULL)
    {
        fprintf(stderr, "Error creating value sequence\n");
        rc = 1;

        goto free_rsl;
    }
    /* Then insert the name-value pair in reverse order */
    rc = globus_list_insert(
            globus_rsl_value_sequence_get_list_ref(new_env_pair),
            globus_rsl_value_make_literal(
                strdup("itsvalue")));
    if (rc != GLOBUS_SUCCESS)
    {
        goto free_env_pair;
    }

    rc = globus_list_insert(
            globus_rsl_value_sequence_get_list_ref(new_env_pair),
            globus_rsl_value_make_literal(
                strdup("EXAMPLE_ENVIRONMENT_VARIABLE")));
    if (rc != GLOBUS_SUCCESS)
    {
        goto free_env_pair;
    }
    /* Now, check to see if the RSL already contains an environment
     * attribute.
     */
    environment_relation_node = globus_list_search_pred(
            globus_rsl_boolean_get_operand_list(rsl),
            example_rsl_attribute_match,
            GLOBUS_GRAM_PROTOCOL_ENVIRONMENT_PARAM);

    if (environment_relation_node == NULL)
    {
        /* Not present yet, create a new relation and insert it into
         * the RSL.
         */
        environment_relation = globus_rsl_make_relation(
                GLOBUS_RSL_EQ,
                strdup(GLOBUS_GRAM_PROTOCOL_ENVIRONMENT_PARAM),
                globus_rsl_value_make_sequence(NULL));
        rc = globus_list_insert(
                globus_rsl_boolean_get_operand_list_ref(rsl),
                environment_relation);
        if (rc != GLOBUS_SUCCESS)
        {
            globus_rsl_free_recursive(environment_relation);
            goto free_env_pair;
        }
    }
    else
    {
        /* Pull the environment relation out of the node returned from the
         * search function
         */
        environment_relation = globus_list_first(environment_relation_node);
    }

    /* Add the new environment binding to the value sequence associated with
     * the environment relation
     */
    rc = globus_list_insert(
        globus_rsl_value_sequence_get_list_ref(
                globus_rsl_relation_get_value_sequence(environment_relation)),
        new_env_pair);
    if (rc != GLOBUS_SUCCESS)
    {
        goto free_env_pair;
    }
    new_env_pair = NULL;

    /* Convert the RSL parse tree to a string */
    rsl_string = globus_rsl_unparse(rsl);

    /*
     * Submit the augmented RSL to the service passed as our first command-line
     * option. If successful, this function will return GLOBUS_SUCCESS,
     * otherwise an integer error code.
     */
    rc = globus_gram_client_job_request(
            argv[1],
            rsl_string,
            0,
            NULL,
            &amp;job_contact);
    if (rc != GLOBUS_SUCCESS)
    {
        fprintf(stderr, "Unable to submit job to %s because %s (Error %d)\n",
                argv[1], globus_gram_client_error_string(rc), rc);
    }
    else
    {
        printf("Job submitted successfully: %s\n", job_contact);
    }

    free(rsl_string);

    if (job_contact)
    {
        free(job_contact);
    }
free_env_pair:
    if (new_env_pair != NULL)
    {
        globus_rsl_value_free_recursive(new_env_pair);
    }
free_rsl:
    globus_rsl_free_recursive(rsl);
deactivate:
    /*
     * Deactivating the module allows it to free memory and close network
     * connections.
     */
    rc = globus_module_deactivate(GLOBUS_GRAM_CLIENT_MODULE);
out:
    return rc;
}
/* End of gram_rsl_example.c */</screen>
</section>
</chapter>
</part>
<part id="_gram_server_developer_8217_s_guide">
<title>GRAM Server Developer&#8217;s Guide</title>
<chapter id="gram5-developer-lrm-adapter-tutorial">
<title>LRM Adapter Tutorial</title>
<section id="_introduction_2">
<title>Introduction</title>
<simpara>GRAM5 provides a resource-independent abstraction to remote job
management. The resource abstraction contains methods for job submission
and cancelling, and a method for monitoring job state changes. This set
of tutorials describes how to implement and bundle all packages needed
for a complete LRM Adapter interface for GRAM5.</simpara>
<simpara>For purposes of this tutorial, we will create a fake LRM adapter that
pretends to run jobs, but in fact just keeps track of jobs and expires
them after the job&#8217;s <literal>max_wall_time</literal> expires. We&#8217;ll call this LRM the
<literal>fake</literal> LRM adapter.</simpara>
</section>
<section id="_parts_of_a_gram5_lrm_adapter">
<title>Parts of a GRAM5 LRM Adapter</title>
<simpara>A GRAM5 LRM Adapter consists of a few parts which work together to
provide a full interface between the GRAM5 Job Manager and the Local
Resource Manager. These parts include:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">RSL Validation File</emphasis>
</term>
<listitem>
<simpara>
     An option file which defines any custom RSL attributes which the LRM Adapter implements, or sets any custom defaults for RSL attributes that the LRM processes. Defining new RSL attributes in this file allows the GRAM5 service to detect some sets of RSL errors without invoking the Perl LRM Adapter Module. For this example, the file will be called <literal>fake.rvf</literal>..
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Perl LRM Adapter Module</emphasis>
</term>
<listitem>
<simpara>
     A Perl module which implements the execution interface to the LRM. This module translates the Resource Specification Language description of a job&#8217;s requirements to a concrete way of starting the job on a particular LRM. For this example, this file will be called <literal>fake.pm</literal>..
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Configuration File</emphasis>
</term>
<listitem>
<simpara>
     The GRAM5 service implements a simple configuration file parser which can be used to provide a way to add site customizations to LRM Adapters. These files are usually shared between the Perl LRM Adapter Module and the Scheduler Event Generator Module. For this example, this file will be called <literal>fake.conf</literal>..
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Gatekeeper Service File</emphasis>
</term>
<listitem>
<simpara>
     The Gatekeeper is a privileged service which authenticates and authorizes clients and then starts a Job Manager process on their behalf. The Gatekeeper Service File contains the LRM-specific command-line options to the job manager. For this example, this file will be called <literal>jobmanager-fork</literal>..
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Scheduler Event Generator Module</emphasis>
</term>
<listitem>
<simpara>
     A dynamic object which parses LRM state and generates job state change events in a generic format for GRAM5 to consume. For this example, the SEG module will be called <literal>libglobus_seg_fake.so</literal>..
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="gram5-lrma-tutorial-rvf">
<title>RSL Validation File</title>
<simpara>Each LRM Adapter can have a custom RSL validation file (RVF) which
indicates which RSL attributes are valid for that LRM, what their
default values are, and when they can be used during a job lifecycle.</simpara>
<simpara>The RVF entries consist of a set of records containing attribute-value
pairs, with a blank line separating records. Each attribute-value pair
is separated by the colon character. The value may be quoted with the
double-quote character, in which case, the value continues until a
second quote character is found; otherwise, the value terminates at end
of line.</simpara>
<section id="_rvf_attributes">
<title>RVF Attributes</title>
<simpara>The attribute names understood by the GRAM5 RVF parser are:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">Attribute</emphasis>
</term>
<listitem>
<simpara>
     The name of an RSL attribute.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Description</emphasis>
</term>
<listitem>
<simpara>
     A textual description of the attribute.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">RequiredWhen</emphasis>
</term>
<listitem>
<simpara>
     A sequence of <ulink url="#gram5-lrma-tutorial-rvf-when-values">WHEN-VALUES</ulink> describing when this RSL attribute must be present.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">DefaultWhen</emphasis>
</term>
<listitem>
<simpara>
     A sequence of <ulink url="#gram5-lrma-tutorial-rvf-when-values">WHEN-VALUES</ulink> describing when the default RSL value will be applied if it&#8217;s not present in the RSL.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">ValidWhen</emphasis>
</term>
<listitem>
<simpara>
     A sequence of <ulink url="#gram5-lrma-tutorial-rvf-when-values">WHEN-VALUES</ulink> describing when the RSL attribute may be present.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Default</emphasis>
</term>
<listitem>
<simpara>
     A literal RSL value sequence containing the default value of the attribute, applied to the RSL when the attribute is not present, but the RSL use matches the <literal>DefaultWhen</literal> value.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Values</emphasis>
</term>
<listitem>
<simpara>
     A sequence of strings enumerating the legal values for the RSL attribute.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Publish</emphasis>
</term>
<listitem>
<simpara>
     When set to <literal>true</literal>, the RSL attribute will be added to the documentation for the LRM Adapter if the RVF is processed by the <emphasis role="strong"><literal>create_rsl_documentation.pl</literal></emphasis> script. Otherwise, it will not be mentioned.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<section id="gram5-lrma-tutorial-rvf-when-values">
<title>RVF When Values</title>
<simpara>The <emphasis>WHEN-VALUES</emphasis> used by the RVF parser are described in this list:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><literal>GLOBUS_GRAM_JOB_SUBMIT</literal></emphasis>
</term>
<listitem>
<simpara>
     RSL Attribute used in a GRAM5 job request to submit a job to an LRM Adapter.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>GLOBUS_GRAM_JOB_RESTART</literal></emphasis>
</term>
<listitem>
<simpara>
     RSL Attribute used in a GRAM5 job request to restart a job which was stopped due to a two-phase commit timeout.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>GLOBUS_GRAM_JOB_STDIO_UPDATE</literal></emphasis>
</term>
<listitem>
<simpara>
     RSL Attribute used in a GRAM5 STDIO_UPDATE signal, which may be sent to a job during the two-phase end state.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_common_rsl_attributes">
<title>Common RSL Attributes</title>
<simpara>The GRAM5 service by default implements a common set of RSL attributes
for all jobs. Not all of these may be relevant to all LRM types, but are
included in the common set so that the same concept will be processed by
the same attribute for each LRM. LRM Adapters can disable particular RSL
attributes if they want by adding the attribute to their RVF file with</simpara>
<screen>Attribute: AttributeName
ValidWhen: ""</screen>
<simpara>The common list of attributes is described in
<ulink url="../..gram5/pi/index.html#gram5-rsl-attribute-summary">../..gram5/pi/index.html#gram5-rsl-attribute-summary</ulink>.</simpara>
</section>
</section>
<section id="_creating_a_rsl_validation_file_for_the_fake_lrm">
<title>Creating a RSL Validation File for the Fake LRM</title>
<simpara>Normally, the RVF for a new LRM Adapter will add any LRM-specific RSL
attributes and perhaps change the DefaultValue for some. For the
<literal>fake</literal> LRM, we&#8217;ll be a bit more complicated and disable most of the
GRAM common RSL attributes and reduce things to indicate the queue and
execution time for the fake jobs. The <literal>fake.rvf</literal> will do the
following:  will do the following:</simpara>
<itemizedlist>
<listitem>
<simpara>
Remove <literal>executable</literal>, <literal>arguments</literal>, <literal>directory</literal>, <literal>environment</literal>, <literal>file_clean_up</literal>, <literal>file_stage_in</literal>, <literal>file_stage_out</literal>, <literal>file_stage_in_shared</literal>, <literal>gass_cache</literal>, <literal>gram_my_job</literal>, <literal>host_count</literal>, <literal>library_path</literal>, <literal>max_cpu_time</literal>, <literal>min_memory</literal>, <literal>project</literal>, <literal>queue</literal>, <literal>remote_io_url</literal>, <literal>scratch_dir</literal>, <literal>stdin</literal>, <literal>stdout</literal>, and <literal>stderr</literal> attributes.
</simpara>
</listitem>
<listitem>
<simpara>
Add a <literal>max_queue_time</literal> attribute, which will be the maximum time a particular fake job will be in the <literal>PENDING</literal> state. This will have a default of 20 minutes.
</simpara>
</listitem>
<listitem>
<simpara>
Add a default value to the <literal>max_wall_time</literal> attribute of 5 minutes.
</simpara>
</listitem>
</itemizedlist>
<example>
<title>fake.rvf</title>
<simpara>Here is the <ulink url="fake.rvf">complete RVF</ulink> for the <literal>fake</literal> LRM Adapter:</simpara>
<screen># Disable a large number of RSL attributes
Attribute: executable
ValidWhen: ""
RequiredWhen: ""

Attribute: directory
ValidWhen: ""
RequiredWhen: ""

Attribute: environment
ValidWhen: ""
RequiredWhen: ""

Attribute: file_clean_up
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_in
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_out
ValidWhen: ""
RequiredWhen: ""

Attribute: file_stage_in_shared
ValidWhen: ""
RequiredWhen: ""

Attribute: gass_cache
ValidWhen: ""
RequiredWhen: ""

Attribute: gram_my_job
ValidWhen: ""
RequiredWhen: ""

Attribute: host_count
ValidWhen: ""
RequiredWhen: ""

Attribute: library_path
ValidWhen: ""
RequiredWhen: ""

Attribute: max_cpu_time
ValidWhen: ""
RequiredWhen: ""

Attribute: min_memory
ValidWhen: ""
RequiredWhen: ""

Attribute: project
ValidWhen: ""
RequiredWhen: ""

Attribute: queue
ValidWhen: ""
RequiredWhen: ""

Attribute: remote_io_url
ValidWhen: ""
RequiredWhen: ""

Attribute: scratch_dir
ValidWhen: ""
RequiredWhen: ""

Attribute: stdin
ValidWhen: ""
RequiredWhen: ""

Attribute: stdout
ValidWhen: ""
RequiredWhen: ""

Attribute: stderr
ValidWhen: ""
RequiredWhen: ""

# Add a new attribute max_queue_time
Attribute: max_queue_time
ValidWhen: GLOBUS_GRAM_JOB_SUBMIT
DefaultWhen: GLOBUS_GRAM_JOB_SUBMIT
RequiredWhen: GLOBUS_GRAM_JOB_SUBMIT
Description: "Maximum time a fake job will be in pending, in seconds. The
              default value is 1200 seconds (20 minutes)"
Default: 1200

# Add a default value and requirement for max_wall_time
Attribute: max_wall_time
DefaultWhen: GLOBUS_GRAM_JOB_SUBMIT
RequiredWhen: GLOBUS_GRAM_JOB_SUBMIT
Default: 300
Description: "Maximum time a fake job will be in the ACTIVE state"</screen>
</example>
</section>
</section>
<section id="_configuration_file">
<title>Configuration File</title>
<simpara>For the fake LRM, there&#8217;s not much to configure: a path to a file where
the LRM should write its job files. For real LRMs, there are other
things which might belong there: paths to LRM-specific executables such
as <emphasis role="strong"><literal>qsub</literal></emphasis>, tuning parameters fo the LRM adapter script such as the
number of available cores per execution node, or the host to contact
when using a remote submit protocol between GRAM the the LRM. The
configuation parameters used by the LRM adapters included in GRAM5 are
described in <ulink url="../..gram5/admin/index.html#gram5-configuring-lrm">../..gram5/admin/index.html#gram5-configuring-lrm</ulink>.</simpara>
<simpara>The LRM adapter configuration files consist of attribute="value" pairs,
which comment lines beginning with the <literal>#</literal> character. For the example
fake LRM, the configuration file looks like this:</simpara>
<screen># log_path is the path to log file that the  fake LRM generates. This file is
# updated each time a job is submitted or cancelled. The default if it is not
# present is ${localstatedir}/fake, which is typically /var/fake
log_path="/tmp"</screen>
<section id="_parsing_the_configuration_file">
<title>Parsing the Configuration File</title>
<simpara>The Globus Toolkit contains API functions for parsing files in the
format used by the LRM configuration files. In Perl, use the
<literal>Globus::Core::Config</literal> class. In C, use the
<emphasis role="strong"><literal>globus_common_get_attribute_from_config_file()</literal></emphasis> function.</simpara>
<section id="_perl_api">
<title>Perl API</title>
<simpara>The <literal>Globus::Core::Config</literal> API is quite simple. The <emphasis role="strong"><literal>new()</literal></emphasis>
constructor parses the configuration file and returns an object
containing the attribute=value pairs. The <emphasis role="strong"><literal>get_attribute()</literal></emphasis> method
returns the value of the named attribute. These functions are used in
<ulink url="#gram5-LRM-Adapter-Perl-Config">the fake LRM Perl Module</ulink>.</simpara>
</section>
<section id="_c_api">
<title>C API</title>
<simpara>The <emphasis role="strong"><literal>globus_common_get_attribute_from_config_file()</literal></emphasis> function will
load the configuration file and return the value of the attribute passed
to it. This function is ued in the SEG module below. Note that this
function returns a pointer to a copy of the string value in the location
pointed to by the <emphasis>value</emphasis> parameter. The caller must free this value.</simpara>
</section>
</section>
</section>
<section id="gram5-lrma-tutorial-perl">
<title>LRM Adapter Perl Module</title>
<simpara>The Perl-language LRM module provides the job submission and cancelling
interface between GRAM5 and the underlying scheduler. Very little has
been added to this part of the scheduler interface since Globus Toolkit
2---if you have a version for an older Globus Toolkit release, you can
ignore most of this tutorial and jump to the
<ulink url="#gram5-lrma-tutorial-perl-changes">#gram5-lrma-tutorial-perl-changes</ulink> section of this tutorial. The
module annotated below is available from link:fake.pm.</simpara>
<section id="_perl_lrm_adapter_module">
<title>Perl LRM Adapter Module</title>
<simpara>The LRM Adapter interface is implemented as a Perl module which is a
subclass of the <literal>Globus::GRAM::JobManager</literal> module. Its name must match
the type string used when the job manager is started, but in all lower
case: for the fake LRM, the module name is
<literal>Globus::GRAM::JobManager::fake</literal> and it is stored in the file
<literal>fake.pm</literal>. Though there are several methods in the . Though there are
several methods in the
<ulink url="#Globus::GRAM::JobManager"><literal>Globus::GRAM::JobManager interface</literal></ulink>,
the only ones which absolutely need to be implemented in a scheduler
module are <emphasis role="strong"><literal>submit</literal></emphasis> and <emphasis role="strong"><literal>cancel</literal></emphasis>. The <emphasis role="strong"><literal>poll</literal></emphasis> can be
used if there is no SEG module for your LRM Adapter, but using polling
can be resource intensive and slow. We&#8217;ll present the methods in the
module one by one, but the entire module can be downloaded from here:
<ulink url="fake.pm">fake.pm</ulink>.</simpara>
<simpara>We&#8217;ll begin by looking at the start of the <literal>fake.pm</literal> source module To
begin the script, we import the GRAM support modules into the LRM
adapter module&#8217;s namespace, declare the module&#8217;s package, and declare
this module as a subclass of the  source module To begin the script, we
import the GRAM support modules into the LRM adapter module&#8217;s namespace,
declare the module&#8217;s package, and declare this module as a subclass of
the <literal>Globus::GRAM::JobManager</literal> module. All LRM adapter packages will
need to do this, substituting the name of the LRM type being implemented
where we see <literal>fake</literal> below.</simpara>
<screen>use Globus::GRAM::Error;
use Globus::GRAM::JobState;
use Globus::GRAM::JobManager;
use Globus::Core::Paths;
use Globus::Core::Config;
use File::Path;
use strict;
use warnings;

package Globus::GRAM::JobManager::fake;

our @ISA = ('Globus::GRAM::JobManager');</screen>
<simpara>Next, we declare any system-specific values which will be read from the
configuration file. In the fake case, we will declare a module-global
directory for job information and for SEG log entries. In real LRM
Adapters, there are often variables which are loaded from the
configuration file for such things as the list of available queues,
paths to executables such as <emphasis role="strong"><literal>mpiexec</literal></emphasis>, and any other
site-specific configuration.</simpara>
<screen>our($job_dir, $fake_seg_dir);

BEGIN
{
    my $config = new Globus::Core::Config(
        '${sysconfdir}/globus/globus-fake.conf');

    $job_dir = $fake_seg_dir = "";

    if ($config)
    {
        $job_dir = $config-&gt;get_attribute("log_path") || "";
    }
    if ($job_dir eq '')
    {
        $job_dir = Globus::Core::Paths::eval_path('${localstatedir}/fake');
    }
}</screen>
<section id="_writing_a_constructor">
<title>Writing a Constructor</title>
<simpara>For LRM Adapter interfaces which need to setup some data before calling
their other methods, they can overload the <emphasis role="strong"><literal>new</literal></emphasis> method which acts
as a constructor. Scheduler scripts which don&#8217;t need any per-instance
initialization will not need to provide a constructor, the default
<emphasis role="strong"><literal>Globus::GRAM::JobManager::new</literal></emphasis> constructor will do the job.</simpara>
<simpara>If you do need to overloaded this method, be sure to call the parent
module&#8217;s constructor to allow it to do its initialization. In this
example, we create an object which includes a sequence number to ensure
that the job ids returned from the LRM script is unique.</simpara>
<screen>sub new
{
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self = $class-&gt;SUPER::new(@_);
    $self-&gt;{sequence} = 0;

    return $self;
}</screen>
<simpara>The job interface methods are called with only one argument: the LRM
Adapter object itself. That object contains a
<literal>Globus::GRAM::JobDescription</literal> object
associated with the request, as well as a few extra values:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">job_id</emphasis>
</term>
<listitem>
<simpara>
     The string returned as the value of JOB_ID in the eturn hash from submit. This won&#8217;t be present for methods called before the job is submitted.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">uniq_id</emphasis>
</term>
<listitem>
<simpara>
     A string associated with this job request by the job manager program. It will be unique for all jobs on a host for all time and might be useful in creating temporary files or LRM-specific processing.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>Now, let&#8217;s look at the methods which will interface to the LRM.</simpara>
</section>
<section id="_submitting_jobs">
<title>Submitting Jobs</title>
<simpara>All LRM adapter modules must implement the <emphasis role="strong"><literal>submit</literal></emphasis> method. This
method is called when the job manager wishes to submit the job to the
LRM. The information in the original job request RSL string is available
to the LRM adapter interface through the <literal>JobDescription</literal> data member
of its hash.</simpara>
<simpara>For most LRM Adapters, this is the longest method to be implemented, as
it must decide what to do with the job description, and convert RSL
elements to something which the LRM can understand.</simpara>
<simpara>For our fake adapter, we will validate that the two RSL attributes we
process are integers, and if so generate a new unique LRM ID and return
it and the state <emphasis role="strong"><literal>Globus::GRAM::JobState::PENDING</literal></emphasis>. Note the call
to <emphasis role="strong"><literal>respond</literal></emphasis> with <literal>GT3_FAILURE_MESSAGE</literal>. This allows the GRAM5
client application to see the context-sensitive error message along with
the general failure code from GRAM5.</simpara>
<screen>sub submit
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $now = time();
    my $jobid;
    my $fh;
    my $pending_time;
    my $active_time;
    my $done_time;
    my $failed_time = 0;

    if ($description-&gt;max_wall_time() != int($description-&gt;max_wall_time()))
    {
        return Globus::GRAM::Error::INVALID_MAX_WALL_TIME;
    }
    elsif ($description-&gt;max_queue_time() !=
        int($description-&gt;max_queue_time()))
    {
        $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Invalid max_queue_time"});

        return Globus::GRAM::Error::INVALID_ATTR;
    }
    $self-&gt;{sequence}++;
    $pending_time = $now;
    $active_time = $pending_time + int($description-&gt;max_queue_time);
    $done_time = $active_time + int($description-&gt;max_wall_time);

    $jobid = sprintf("%.63s", "$$".$self-&gt;{sequence}.".$now");

    if (!open($fh, "&gt;&gt;$job_dir/fakejob.log"))
    {
        $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Unable to write job file"});
        return Globus::GRAM::Error::INVALID_SCRIPT_STATUS;
    }
    print $fh "$jobid;$pending_time;$active_time;$done_time;$failed_time\n";
    close($fh);

    return { JOB_STATE =&gt; Globus::GRAM::JobState::PENDING,
             JOB_ID =&gt; $jobid };
}</screen>
<simpara>That finishes the submit method. Most of the functionality for the
scheduler interface is now written.</simpara>
</section>
<section id="_polling_job_state">
<title>Polling Job State</title>
<simpara>GRAM5 requires some way to determine the state of a job. In most
systems, writing a Scheduler Event Generator module will provide the
best performance and lowest resource overhead. However, when developing
an LRM adapter, it is helpful to implement the polling interface so that
the submission and cancel mechanism can be tested independent of having
the SEG module completed. For the <literal>fake</literal> LRM Adapter, we&#8217;ll write a
simple <emphasis role="strong"><literal>poll</literal></emphasis> method which will compare the current time with the
time when the job was originally submitted.</simpara>
<screen>sub poll
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $state;
    my $pid;
    my $now;
    my $fh;
    my $pending_time = 0;
    my $active_time;
    my $done_time;
    my $failed_time;
    my $seqno;

    my $jobid = $description-&gt;jobid();

    if(!defined $jobid)
    {
        $self-&gt;log("poll: job id undefined!");
        return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
    }

    open($fh, "&lt;$job_dir/fakejob.log");

    # Multiple matches might occur if the job is cancelled, so we keep looping
    # until EOF
    while (&lt;$fh&gt;)
    {
        chomp;

        my @fields = split(/;/);

        if ($fields[0] ne $jobid)
        {
            next;
        }

        $pending_time = $fields[1];
        $active_time = $fields[2];
        $done_time = $fields[3];
        $failed_time = $fields[4];
    }
    close($fh);

    $now = time();

    if ($pending_time == 0)
    {
        # not found
        $state = Globus::GRAM::JobState::FAILED;
    }
    elsif (int($failed_time) != 0)
    {
        $state = Globus::GRAM::JobState::FAILED;
    }
    elsif ($now &lt; int($active_time))
    {
        $state = Globus::GRAM::JobState::PENDING;
        return
    }
    elsif ($now &lt; int($done_time))
    {
        $state = Globus::GRAM::JobState::ACTIVE;
    }
    else
    {
        $state = Globus::GRAM::JobState::DONE;
    }

    return { JOB_STATE =&gt; $state };
}</screen>
</section>
<section id="_cancelling_jobs">
<title>Cancelling Jobs</title>
<simpara>All LRM Adapter modules must also implement the <emphasis role="strong"><literal>cancel</literal></emphasis> method.
The purpose of this method is to cancel a job, whether it&#8217;s already
running or waiting in a queue.</simpara>
<simpara>This method will be given the job ID as part of the JobDescription
object in the manager object. If the LRM interface provides feedback
that the job was cancelled successfully, then we can return a JOB_STATE
change to the FAILED state. Otherwise we can return an empty hash
reference, and let either the Scheduler Event Generator or a subsequent
call to poll determine when the state change occurs.</simpara>
<simpara>For the <literal>fake</literal> LRM adapter, we will update the job file with a
cancellation time and return the <literal>Globus::GRAM::JobState::FAILED</literal>
state change.</simpara>
<screen>sub cancel
{
    my $self = shift;
    my $description = $self-&gt;{JobDescription};
    my $pgid;
    my $jobid = $description-&gt;jobid();
    my $fh;
    my $pending_time = 0;
    my $active_time;
    my $done_time;
    my $failed_time ;
    my $now = time();

    if(!defined $jobid)
    {
        $self-&gt;log("cancel: no jobid defined!");
        return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
    }

    open($fh, "&lt;$job_dir/fakejob.log");

    # Multiple matches might occur if the job is cancelled, so we keep looping
    # until EOF
    while (&lt;$fh&gt;)
    {
        chomp;

        my @fields = split(/;/);

        if ($fields[0] ne $jobid)
        {
            next;
        }

        $pending_time = $fields[1];
        $active_time = $fields[2];
        $done_time = $fields[3];
        $failed_time = $fields[4];
    }
    close($fh);

    $self-&gt;log("cancel job " . $jobid);
    if ($now &lt; int($done_time) &amp;&amp; int($failed_time) == 0)
    {
        $failed_time = $now;
        $done_time = 0;
        if (!open($fh, "&gt;&gt;$job_dir/fakejob.log"))
        {
            $self-&gt;respond({GT3_FAILURE_MESSAGE =&gt; "Unable to write job file"});
            return Globus::GRAM::Error::INVALID_SCRIPT_STATUS;
        }
        print $fh "$jobid;$pending_time;$active_time;$done_time;$failed_time\n";
        close($fh);
    }

    return { JOB_STATE =&gt; Globus::GRAM::JobState::FAILED };
}</screen>
</section>
<section id="_end_of_the_script">
<title>End of the script</title>
<simpara>It is required that all perl modules return a non-zero value when they
are parsed. To do this, make sure the last line of your module consists
of:</simpara>
<screen>1;</screen>
</section>
</section>
</section>
<section id="gram5-developer-lrm-adapter-tutorial-seg">
<title>LRM SEG Module</title>
<section id="_intro">
<title>Intro</title>
<simpara>The Scheduler Event Generator (SEG) module provides an efficient job
monitoring interface between GRAM5 and the underlying local resource
manager. In most cases, the SEG module parses a log generated by the
local resource manager which contains information about job state
changes and then uses the
<ulink url="http://www.globus.org/api/c-globus-{$version}/globus%5fscheduler%5fevent%5fgenerator/html/group%5f%5fseg%5f%5fapi.html">SEG
API</ulink> to signal job state changes as they occur.</simpara>
<simpara>A SEG module is implemented as a shared library which is loaded as a
globus extension. This means that the only entry point to the library is
a globus_module_descriptor, which defines activation and deactivation
functions for the library. For this tutorial, we will build up the SEG
module piecewise, but the <ulink url="seg_fake_module.c">entire fake SEG module
source</ulink> can be downloaded as well.</simpara>
</section>
<section id="_outline">
<title>Outline</title>
<simpara>The outline for our SEG module is:</simpara>
<screen></screen>
<simpara>From this outline, we&#8217;ll explain the various sections of the source file
below.</simpara>
</section>
<section id="gram5-lrm-seg-depdendencies">
<title>LRM Module Dependencies</title>
<simpara>The LRM module uses the globus_common API from Globus for its linked
list, mutual exclusion, timed events, and module dependency tracking. It
also uses the Scheduler Event Generator APIs, which provide functions
for defining and emitting LRM events.</simpara>
<simpara>For our implementation, we&#8217;ll need to include the headers for the
Globus
modules we&#8217;ll be using. In this case we&#8217;ll be using
<literal>globus_common.h</literal>,
, <literal>globus_scheduler_event_generator.h</literal> (which
includes the API for
emitting SEG events), and  (which includes the API
for emitting SEG
events), and <literal>globus_scheduler_event_generator_app.h</literal>
(which includes
the SEG event type definitions).  (which includes the
SEG event type
definitions).</simpara>
<screen>#include
"globus_common.h"
#include "globus_scheduler_event_generator.h"
#include
"globus_scheduler_event_generator_app.h"</screen>
</section>
<section id="gram5-lrm-seg-module-specific-data">
<title>Module Specific Data</title>
<simpara>For the fake LRM, we need to keep some global state to keep track of
what we&#8217;ve parsed from our LRM&#8217;s log file, and what events are we should
be sending in the future. To do this, we define two data structures, a
<literal>fake_job_info_t</literal> which defines the set of event timestamps associated
with a job, and <literal>fake_state_t</literal> which contains the state of the fake
SEG parser.</simpara>
<screen></screen>
<simpara>For the <literal>fake_job_info_t</literal> structure, we will want to keep track of
the
LRM id (an up to 64-character long string), and the timestamps for
the
pending, active, failed, and done events for the job. We use
the
timestamp value of <literal>0</literal> to indicate an event which will not happen
or
has already been processed.</simpara>
<screen>typedef struct
{
    char
jobid[64];
    time_t pending;
    time_t active;
    time_t failed;

time_t done;
}
fake_job_info_t;</screen>
<simpara>In addition, we will keep a
null initializer for the <literal>fake_job_info_t</literal>
structure so that we can
simply initialize dynamically allocated data.</simpara>
<screen>/* A
statically-initialized empty job info which is used to initialize
 *
dynamically allocated fake_job_info_t structs
 */
static fake_job_info_t
fake_job_info_initializer;</screen>
<simpara>For the LRM parser state, we will keep track of the start time for
which
we will emit events, the path to the fake job log, a file pointer
open
to that log, and a list of <literal>fake_job_info_t</literal> structs for each job
we
have data for. We also use a mutex/condition variable combination
to
block deactivation until all callback functions have completed. The
data
in this struct is initialized in the module&#8217;s activation function
below.</simpara>
<screen>/**
 * State of the FAKE log file parser.
 */
static
struct
{
    /** Timestamp of when to start generating events from */

time_t                              start_timestamp;
    /** Log file
path */
    char *                              log_path;
    /** Log
file pointer */
    FILE *                              log;
    /**
List of job info containing future info we might need to
      * turn
into job state changes
      */
    globus_list_t *
jobs;
    /**
     * shutdown mutex
     */
    globus_mutex_t
mutex;
    /**
     * shutdown condition
     */
    globus_cond_t
cond;
    /**
     * shutdown flag
     */
    globus_bool_t
shutdown_called;
    /**
     * callback count
     */
    int
callback_count;
} globus_l_fake_state;</screen>
</section>
<section id="gram5-lrm-seg-module-prototypes">
<title>Module Specific Prototypes</title>
<simpara>For our SEG, we define a small number of static functions to process the
fake job log. These include our activation and deactivation functions,
and our event callback which is called periodically to process the fake
job log. We also have a couple of utility functions to look up entries
in the job list and a predicate used to sort a list of SEG events by
timestamp and jobid.</simpara>
<screen>static
int
globus_l_fake_module_activate(void);

static
int
globus_l_fake_module_deactivate(void);

static
void
globus_l_fake_read_callback(void *user_arg);

static
int
globus_l_fake_find_by_job_id(void * datum, void * arg);

static
int
globus_l_fake_compare_events(void * low_datum, void * high_datum, void * relation_args);</screen>
</section>
<section id="gram5-lrm-seg-module-descriptor">
<title>Extension Module Descriptor</title>
<simpara>The SEG dynamically loads our code using the Globus Extension API. To
implement the interface it needs, we must define an extension descriptor
so that it can find the entry point to our library. This module
descriptor contains pointers to the activation and deactivation
functions we prototyped above. It can contain other pointers but they
aren&#8217;t needed for our module implementation so we leave them as NULL.</simpara>
<screen>GlobusExtensionDefineModule(globus_seg_fake) =
{
    "globus_seg_fake",
    globus_l_fake_module_activate,
    globus_l_fake_module_deactivate,
    NULL,
    NULL,
    NULL
};</screen>
</section>
<section id="gram5-lrm-seg-module-activation">
<title>Module Activation</title>
<simpara>The entry point to our LRM-specific module is the activation function.
This function is invoked by the <emphasis role="strong"><literal>globus-scheduler-event-generator</literal></emphasis>
program when it starts and dynamically loads the LRM-specific module. It
is not passed any parameters, and is expected to return
<literal>GLOBUS_SUCCESS</literal> if it is able to activate itself. Typically the
activation function will do the following:</simpara>
<screen>static
int
globus_l_fake_module_activate(void)
{






    return result;
} /* globus_l_fake_module_activate() */</screen>
<simpara>For our activation function, we&#8217;ll use variables to store the path
to
the configuration file as well as return values from functions we
call.</simpara>
<screen>char *                              config_path =
NULL;
char *                              log_dir;
int
rc;
globus_result_t                     result =
GLOBUS_SUCCESS;</screen>
<simpara>The headers we&#8217;ve just included contain the module descriptors which
we
will activate in our LRM-specific activation function, so that we
are
able to use the APIs in those modules. Our module is only ever
activated
by the SEG module, so we shouldn&#8217;t activate it. In the
activation
function for our module, we&#8217;ll include this fragment</simpara>
<screen>rc = globus_module_activate(GLOBUS_COMMON_MODULE);
if (rc !=
GLOBUS_SUCCESS)
{
    fprintf(stderr, "Fatal error activating
GLOBUS_COMMON_MODULE\n");

    result = GLOBUS_FAILURE;
    goto
activation_failure;
}</screen>
<simpara>To handling deactivation safely, we&#8217;ll create a mutex and
condition
variable to handle the case of when a shutdown is called while
our event
handler is running. In that case, we&#8217;ll set the
<emphasis role="strong"><literal>shutdown_called</literal></emphasis>
variable to <literal>GLOBUS_TRUE</literal> and then wait until
the callback has
terminated. Here we just set the variables to their
non-shutdown values.</simpara>
<screen>rc =
globus_mutex_init(&amp;globus_l_fake_state.mutex, NULL);
if (rc !=
GLOBUS_SUCCESS)
{
    result = GLOBUS_FAILURE;
    goto
mutex_init_failed;
}

rc = globus_cond_init(&amp;globus_l_fake_state.cond,
NULL);
if (rc != GLOBUS_SUCCESS)
{
    result = GLOBUS_FAILURE;
    goto
cond_init_failed;
}
globus_l_fake_state.shutdown_called =
GLOBUS_FALSE;
globus_l_fake_state.callback_count = 0;</screen>
<section id="gram5-lrm-module-activate-read-configuration">
<title>LRM SEG Module Configuration</title>
<simpara>There are two main pieces of configuation information we&#8217;ll need
to
process SEG events: the earliest timestamp we care about (which we
get
from the SEG module) and the path to our fake job log file (which we
get
from our configuration file as in the perl module).</simpara>
<simpara>So first, to get the timestamp, we&#8217;ll use the
<emphasis role="strong"><literal>globus_scheduler_event_generator_get_timestamp()</literal></emphasis> function.</simpara>
<screen>result = globus_scheduler_event_generator_get_timestamp(
        &amp;globus_l_fake_state.start_timestamp);
if (result != GLOBUS_SUCCESS)
{
    goto get_timestamp_failed;
}</screen>
<simpara>Then, to get the configuration file data, we first construct the path to
the configuration file and then pull out the configuration attribute
it is not found.  if it is not found.</simpara>
<screen>result = globus_eval_path(
        "${sysconfdir}/globus/globus-fake.conf",
        &amp;config_path);
if (result != GLOBUS_SUCCESS || config_path == NULL)
{
    goto get_config_path_failed;
}
result = globus_common_get_attribute_from_config_file(
        "",
        config_path,
        "log_path",
        &amp;log_dir);

/* This default must match fake.pm's default for things to work */
if (result != GLOBUS_SUCCESS)
{
    result = globus_eval_path("${localstatedir}/fake", &amp;log_dir);
}

if (result != GLOBUS_SUCCESS)
{
    goto get_log_dir_failed;
}

globus_l_fake_state.log_path =
    globus_common_create_string("%s/fakejob.log", log_dir);
if (globus_l_fake_state.log_path == NULL)
{
    result = GLOBUS_FAILURE;

    goto get_log_path_failed;
}</screen>
</section>
<section id="gram5-lrm-module-activate-register-event">
<title>Register Event</title>
<simpara>The next main action the activation function does is to register an
event to happen later to process the events in the LRM log. For this, we
use the <emphasis role="strong"><literal>globus_callback_register_oneshot()</literal></emphasis> function to register
an event handler to execute as soon as possible within the
<emphasis role="strong"><literal>globus-scheduduler-event-generator</literal></emphasis> program. The callback
function in this case is the globus_l_fake_read_callback() function
defined later.</simpara>
<screen>result = globus_callback_register_oneshot(
        NULL,
        NULL,
        globus_l_fake_read_callback,
        &amp;globus_l_fake_state);
if (result != GLOBUS_SUCCESS)
{
    goto register_oneshot_failed;
}
globus_l_fake_state.callback_count++;</screen>
</section>
<section id="gram5-lrm-module-activate-cleanup-on-failure">
<title>Cleanup on Failure</title>
<simpara>Here we handle the errors that might have occurred above and free
temporarily used memory. In case of a failure, <emphasis role="strong"><literal>result</literal></emphasis> is set to
something other than <literal>GLOBUS_SUCCESS</literal>.</simpara>
<screen>register_oneshot_failed:
get_log_path_failed:
    if (result != GLOBUS_SUCCESS)
    {
        free(globus_l_fake_state.log_path);
    }
    free(log_dir);
get_log_dir_failed:
    free(config_path);
get_config_path_failed:
get_timestamp_failed:
    if (result != GLOBUS_SUCCESS)
    {
malloc_state_failed:
        globus_cond_destroy(&amp;globus_l_fake_state.cond);
cond_init_failed:
        globus_mutex_destroy(&amp;globus_l_fake_state.mutex);
mutex_init_failed:
        globus_module_deactivate(GLOBUS_COMMON_MODULE);
    }
activation_failure:</screen>
</section>
</section>
<section id="gram5-lrm-seg-module-deactivation">
<title>Module Deactivation</title>
<simpara>For our deactivation function, we will wait use the shutdown handling
variables in the state structure to wait until all outstanding callback
have terminated and then free memory associated with the state.</simpara>
<screen>static
int
globus_l_fake_module_deactivate(void)
{


} /* globus_l_fake_module_deactivate() */</screen>
<simpara>To handle shutdown safely, we must wait until pending callbacks
have
terminated. To do this, we set the <literal>shutdown_called</literal> field in
the
state structure and wait until the <literal>callback_count</literal> field is
<literal>0</literal>.
Inside the callback function, if we see that the
<literal>shutdown_called</literal>
field is <literal>GLOBUS_TRUE</literal> then it will not reregister
itself and will
signal when it terminates.</simpara>
<screen>globus_mutex_lock(&amp;globus_l_fake_state.mutex);
globus_l_fake_state.shutdown_called
= GLOBUS_TRUE;
while (globus_l_fake_state.callback_count &gt; 0)
{

globus_cond_wait(&amp;globus_l_fake_state.cond,
&amp;globus_l_fake_state.mutex);
}
globus_mutex_unlock(&amp;globus_l_fake_state.mutex);</screen>
<simpara>Finally, we&#8217;ll free data we allocated in the activation function.</simpara>
<screen>globus_mutex_destroy(&amp;globus_l_fake_state.mutex);
globus_cond_destroy(&amp;globus_l_fake_state.cond);
if
(globus_l_fake_state.log_path)
{

free(globus_l_fake_state.log_path);
}
if (globus_l_fake_state.log)
{

fclose(globus_l_fake_state.log);
}
while
(!globus_list_empty(globus_l_fake_state.jobs))
{
    fake_job_info_t
*info;

    info = globus_list_remove(

&amp;globus_l_fake_state.jobs,
            globus_l_fake_state.jobs);

free(info);
}

globus_module_deactivate(GLOBUS_COMMON_MODULE);

return
GLOBUS_SUCCESS;</screen>
</section>
<section id="gram5-lrm-seg-module-process">
<title>Process Events</title>
<simpara>The main activity of our LRM module is to generate SEG events so that a
job manager will be able to efficient manage its jobs. In this code, we
will parse our log file periodically, and fire off any events which are
to have occurred for the jobs in the fake job log. The structure of the
processing function is this</simpara>
<screen>static
void
globus_l_fake_read_callback(void * arg)
{








} /* globus_l_fake_read_callback() */</screen>
<screen>char                                jobid[64];
globus_list_t
*l, *events;
fake_job_info_t                     *info;
globus_reltime_t
delay = {0};
time_t                              now;
unsigned long
pending_time, active_time, done_time,
failed_time;
globus_scheduler_event_t            *e;
time_t
last_timestamp;
globus_result_t                     result =
GLOBUS_SUCCESS;</screen>
<simpara>To check for shutdown, we&#8217;ll first lock the mutex associated with
the
state structure and check if the <literal>shutdown_called</literal> field is set
to
true. If so, we&#8217;ll jump to our error handling code.</simpara>
<screen>globus_mutex_lock(&amp;globus_l_fake_state.mutex);
if
(globus_l_fake_state.shutdown_called)
{
    result = GLOBUS_FAILURE;

goto error;
}</screen>
<simpara>In general, we&#8217;ll keep a file open to parse the log, but the first
time
around, or before any events have been written, the log file might
not
exist. So we&#8217;ll check to see if we have a <literal>NULL</literal> file pointer, and
if
so, try to open the file. Once opened, we&#8217;ll use line buffering while
we
process the file.</simpara>
<screen>if (globus_l_fake_state.log == NULL)
{

globus_l_fake_state.log = fopen(globus_l_fake_state.log_path, "r");

if (globus_l_fake_state.log != NULL)
    {
        /* Enable line
buffering */
        setvbuf(globus_l_fake_state.log, NULL, _IOLBF, 0);

}
}
if (globus_l_fake_state.log == NULL)
{
    result = GLOBUS_FAILURE;

GlobusTimeReltimeSet(delay, 30, 0);
    goto reregister;
}</screen>
<simpara>Now we will read all of the log entries from our current position
until
the end of file. If we&#8217;ve already parsed an entry for a particular
job,
we will zero out its timestamps and replace with the new timestamps
to
handle cancel events in the fake job log.</simpara>
<screen>/* previous
read might have hit EOF, so clear it before trying to read
*/
clearerr(globus_l_fake_state.log);

/* Read any new job info from the
log */
while (fscanf(globus_l_fake_state.log,
"%63[^;];%ld;%ld;%ld;%ld\n",
            jobid,

&amp;pending_time,
            &amp;active_time,
            &amp;done_time,

&amp;failed_time) == 5)
{
    l =
globus_list_search_pred(globus_l_fake_state.jobs,
globus_l_fake_find_by_job_id, jobid);
    if (l != NULL)
    {

info = globus_list_first(l);
        /* If there's a second entry for
the same job, it was cancelled, so
         * clear done/failed
timestamps and copy them below
         */
        info-&gt;done =
info-&gt;failed = 0;
    }
    else
    {
        /* First time we've seen
this job, set jobid and insert*/
        info =
malloc(sizeof(fake_job_info_t));
        *info =
fake_job_info_initializer;
        strcpy(info-&gt;jobid, jobid);

globus_list_insert(&amp;globus_l_fake_state.jobs, info);
    }
    /* set
timestamps */
    info-&gt;pending = pending_time;
    info-&gt;active =
active_time;
    info-&gt;done = done_time;
    info-&gt;failed =
failed_time;
}</screen>
<simpara>Now, we&#8217;ll walk our list of jobs and create SEG events for each
state
transition which has occurred since our last timestamp and the
current
time. These events will be out of order in our events list,
because they
are created in order of job IDs in the jobs list, and not
in timestamp
list. We&#8217;ll deal with this later. Note that we set the
timestamp values
in the job info to 0 after we create an event. This
keeps us from
generating an event multiple times.</simpara>
<screen>/* Create
set of events that we'll emit this time through: jobs which will
 *
changed state since our last event update
 */
now = time(NULL);

events
= NULL;
for (l = globus_l_fake_state.jobs; l != NULL; l =
globus_list_rest(l))
{
    info = globus_list_first(l);

    if
(info-&gt;pending &gt;= globus_l_fake_state.start_timestamp &amp;&amp;

info-&gt;pending &lt; now)
    {
        e =
malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type =
GLOBUS_SCHEDULER_EVENT_PENDING;
        e-&gt;job_id = info-&gt;jobid;

e-&gt;timestamp = info-&gt;pending;
        e-&gt;exit_code = 0;

e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;pending
= 0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;active
&gt;= globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;active &lt; now)

{
        e = malloc(sizeof(globus_scheduler_event_t));

e-&gt;event_type = GLOBUS_SCHEDULER_EVENT_ACTIVE;
        e-&gt;job_id =
info-&gt;jobid;
        e-&gt;timestamp = info-&gt;active;
        e-&gt;exit_code =
0;
        e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;


info-&gt;active = 0;

        globus_list_insert(&amp;events, e);
    }
    if
(info-&gt;done != 0 &amp;&amp;
        info-&gt;done &gt;=
globus_l_fake_state.start_timestamp &amp;&amp;
        info-&gt;done &lt; now)
    {

e = malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type =
GLOBUS_SCHEDULER_EVENT_DONE;
        e-&gt;job_id = info-&gt;jobid;

e-&gt;timestamp = info-&gt;done;
        e-&gt;exit_code = 0;

e-&gt;failure_code = 0;
        e-&gt;raw_event = NULL;

        info-&gt;done =
0;

        globus_list_insert(&amp;events, e);
    }
    if (info-&gt;failed
!= 0 &amp;&amp;
        info-&gt;failed &gt;= globus_l_fake_state.start_timestamp &amp;&amp;

info-&gt;failed &lt; now)
    {
        e =
malloc(sizeof(globus_scheduler_event_t));
        e-&gt;event_type =
GLOBUS_SCHEDULER_EVENT_FAILED;
        e-&gt;job_id = info-&gt;jobid;

e-&gt;timestamp = info-&gt;failed;
        e-&gt;exit_code = 0;

e-&gt;failure_code = GLOBUS_GRAM_PROTOCOL_ERROR_USER_CANCELLED;

e-&gt;raw_event = NULL;

        info-&gt;failed = 0;


globus_list_insert(&amp;events, e);
    }
}</screen>
<simpara>Now we have a set of events, we will sort them by timestamp and then
use
the SEG API to emit them. After we&#8217;ve emitted an event, we have to
free
it. If the event is a terminal one (DONE or FAILED) we&#8217;ll remove
the job
from the list of jobs in the state structure.</simpara>
<screen>/* Sort
the events so that they're in timestamp order */
events =
globus_list_sort_destructive(events, globus_l_fake_compare_events,
NULL);

/* Emit events in proper order */
while (!
globus_list_empty(events))
{
    e = globus_list_remove(&amp;events,
events);
    last_timestamp = e-&gt;timestamp;

    switch (e-&gt;event_type)

{
        case GLOBUS_SCHEDULER_EVENT_PENDING:

globus_scheduler_event_pending(e-&gt;timestamp, e-&gt;job_id);

break;
        case GLOBUS_SCHEDULER_EVENT_ACTIVE:

globus_scheduler_event_active(e-&gt;timestamp, e-&gt;job_id);

break;
        case GLOBUS_SCHEDULER_EVENT_FAILED:

globus_scheduler_event_failed(e-&gt;timestamp, e-&gt;job_id,
e-&gt;failure_code);
            break;
        case
GLOBUS_SCHEDULER_EVENT_DONE:

globus_scheduler_event_done(e-&gt;timestamp, e-&gt;job_id, e-&gt;exit_code);

break;
    }
    /* If this is a terminal event, we can remove the job
from the list */
    if (e-&gt;event_type == GLOBUS_SCHEDULER_EVENT_FAILED
||
        e-&gt;event_type == GLOBUS_SCHEDULER_EVENT_DONE)
    {
        l
= globus_list_search_pred(globus_l_fake_state.jobs,
globus_l_fake_find_by_job_id, e-&gt;job_id);
        info =
globus_list_remove(&amp;globus_l_fake_state.jobs, l);
        free(info);

}

    free(e);
}
globus_l_fake_state.start_timestamp =
last_timestamp;</screen>
<simpara>We&#8217;ll register a new callback instance now (provided we haven&#8217;t had
an
error occur) so that we can continue to process jobs later.</simpara>
<screen>GlobusTimeReltimeSet(delay, 1, 0);
reregister:
result =
globus_callback_register_oneshot(
        NULL,
        &amp;delay,

globus_l_fake_read_callback,
        &amp;globus_l_fake_state);
if (result
!= GLOBUS_SUCCESS)
{
    goto
error;
}
globus_mutex_unlock(&amp;globus_l_fake_state.mutex);
return;</screen>
<simpara>If an error occurred registering the event or the shutdown handler
is
invoked, we&#8217;ll exit this function without registering a new event.
In
the case the shutdown handling is in place, we&#8217;ll signal that as well</simpara>
<screen>error:
if (globus_l_fake_state.shutdown_called)
{

globus_l_fake_state.callback_count--;

    if
(globus_l_fake_state.callback_count == 0)
    {

globus_cond_signal(&amp;globus_l_fake_state.cond);
    }
}
else
{

fprintf(stderr,
            "FATAL: Unable to register callback. FAKE
SEG exiting\n");

exit(EXIT_FAILURE);
}
globus_mutex_unlock(&amp;globus_l_fake_state.mutex);

return;</screen>
</section>
<section id="gram5-lrm-seg-module-utils">
<title>Utility Functions</title>
<simpara>We have two utility functions to implement for this module to manage our
lists of pending events and jobs.</simpara>
<screen></screen>
<simpara>The <emphasis role="strong"><literal>globus_l_fake_find_by_job_id()</literal></emphasis> function is used to
search
the <literal>jobs</literal> field of the state structure for a
<literal>fake_job_info_t</literal>
containing info about a particular job. This
predicate returns a
non-zero value if the <emphasis>datum</emphasis> passed to the function
has the same job ID
as the <emphasis>arg</emphasis> parameter.</simpara>
<screen>static
int
globus_l_fake_find_by_job_id(void * datum, void *
arg)
{
    fake_job_info_t * info = datum;

    return
(strcmp(info-&gt;jobid, arg) == 0);
} /* globus_l_fake_find_by_job_id()
*/</screen>
<simpara>The <emphasis role="strong"><literal>globus_l_fake_compare_events()</literal></emphasis> function is used as
a
predicate to compare the timestamps and job ids of a pair of events.
If
the <emphasis>log_datum</emphasis> points to an event which happens earlier in the
job
lifecycle than the <emphasis>high_datum</emphasis>, this function returns
<literal>GLOBUS_TRUE</literal>;
otherwise it returns <literal>GLOBUS_FALSE</literal>.</simpara>
<screen>static
int
globus_l_fake_compare_events(void * low_datum,
void * high_datum, void * relation_args)
{
    globus_scheduler_event_t
*low_event = low_datum, *high_event = high_datum;

    if
(low_event-&gt;timestamp &lt; high_event-&gt;timestamp)
    {
        return
GLOBUS_TRUE;
    }
    else if (low_event-&gt;timestamp ==
high_event-&gt;timestamp)
    {
        if (low_event-&gt;event_type ==
GLOBUS_SCHEDULER_EVENT_PENDING)
        {
            return
GLOBUS_TRUE;
        }
        else if (low_event-&gt;event_type ==
GLOBUS_SCHEDULER_EVENT_ACTIVE &amp;&amp;
                 high_event-&gt;event_type
!= GLOBUS_SCHEDULER_EVENT_PENDING)
        {
            return
GLOBUS_TRUE;
        }
        else if (high_event-&gt;event_type !=
GLOBUS_SCHEDULER_EVENT_PENDING &amp;&amp;

high_event-&gt;event_type != GLOBUS_SCHEDULER_EVENT_ACTIVE)
        {

return GLOBUS_TRUE;
        }
    }
    return GLOBUS_FALSE;
} /*
globus_l_fake_compare_events() */</screen>
</section>
</section>
<section id="gram5-lrma-tutorial-perl-changes">
<title>Changes from Previous Versions</title>
<section id="_changes_in_gt_5_2">
<title>Changes in GT 5.2</title>
<simpara>GRAM5 is now designed to work as a native debian or RPM package, with
default configuration being done at configuration time, so the setup
script description has been removed.</simpara>
</section>
<section id="_changes_in_gt_5_0">
<title>Changes in GT 5.0</title>
<simpara>GRAM5 is based again on the C code base used for GRAM2 (also known as
Pre-WS GRAM). The SEG module interface from GRAM4 is retained and
optionally used by GRAM5. The GRAM job manager will avoid reloading the
GRAM LRM Adapter script for each operation, so all variables not
intended to be global state in the Perl LRM Adapter module must be
lexically scoped, or state will leak between jobs and cause potentially
cause problems.</simpara>
</section>
<section id="_changes_in_gt_4_0">
<title>Changes in GT 4.0</title>
<section id="_module_methods">
<title>Module Methods</title>
<simpara>The GT-4.0 ws-GRAM service only calls a subset of the Perl methods which
were used by the pre-ws GRAM services. Most importantly for script
implementors, the polling method is no longer used. Instead, the
scheduler-event-generator monitors jobs to signal the service when job
change changes occur. Staging is now done via the Reliable File Transfer
service, so the file_stage_in and file_stage_out methods are no longer
called. Schedulers typically did not implement the staging methods, so
this shouldn&#8217;t affect most scheduler modules.</simpara>
<simpara>That being said, scheduler implementers which would like to have their
scheduler both with pre-ws GRAM and WS-GRAM should definitely implement
the poll() method described in the pre-WS version of this tutorial.</simpara>
</section>
<section id="_gass_cache">
<title>GASS Cache</title>
<simpara>The GT-4.0 ws-GRAM service does not use the GASS cache for storing
temporary files or for staging files.</simpara>
</section>
</section>
<section id="_changes_in_gt_3_2">
<title>Changes in GT 3.2</title>
<simpara>In GT 3.2, additional error message context info was added. Scripts can
optionally add one of these fields to the return hash from an operation
to provide extra error information to the client:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">GT3_FAILURE_MESSAGE</emphasis>
</term>
<listitem>
<simpara>
     Error message from underlying script processing indicating what caused a job request to fail
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">GT3_FAILURE_TYPE</emphasis>
</term>
<listitem>
<simpara>
     One of <literal>filestagein</literal>, <literal>filestageout</literal>, <literal>filestageinshared</literal>, <literal>executable</literal>, or <literal>stdin</literal> indicating what job request element caused a staging fault.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">GT3_FAILURE_SOURCE</emphasis>
</term>
<listitem>
<simpara>
     Source URL or file for a failed staging operation
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">GT3_FAILURE_DESTINATION</emphasis>
</term>
<listitem>
<simpara>
     Destination URL or file for a failed staging operation
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
</chapter>
</part>
<part id="_gram5_developer_8217_s_reference">
<title>GRAM5 Developer&#8217;s Reference</title>
<chapter id="gram5-apis">
<title>APIs</title>
<section id="_c_api_documentation_links">
<title>C API Documentation Links</title>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><ulink url="http://toolkit.globus.org/api/c-globus-6.0/group%5f%5fglobus%5f%5fgram%5f%5fprotocol.html">GRAM Protocol</ulink></emphasis>
</term>
<listitem>
<simpara>
     Low-level functions for processing GRAM protocol messages. Symbolic constants for RSL attributes, signals, and job states.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><ulink url="http://www.globus.org/api/c-globus-6.0/group%5f%5fglobus%5f%5fgram%5f%5fclient.html">GRAM Client</ulink></emphasis>
</term>
<listitem>
<simpara>
     Functions for submitting job requests, sending signals, and listening for job state updates.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><ulink url="http://www.globus.org/api/c-globus-6.0/group%5f%5fglobus%5f%5frsl.html">RSL</ulink></emphasis>
</term>
<listitem>
<simpara>
     Functions for parsing and manipulating job specifications in the RSL language.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><ulink url="http://www.globus.org/api/c-globus-6.0/group%5f%5fglobus%5f%5fscheduler%5f%5fevent%5f%5fgenerator.html">Scheduler Event Generator</ulink></emphasis>
</term>
<listitem>
<simpara>
     Functions for generating and parsing LRM-independent job state change events.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_gram5_perl_api_reference">
<title>GRAM5 Perl API Reference</title>
<simpara>GRAM5 also provides a Perl API for creating LRM interface implementations.</simpara>
<section id="Globus::GRAM::Error">
<title>GLOBUS::GRAM::ERROR(3pm)</title>
<section id="_name">
<title>NAME</title>
<simpara>Globus::GRAM::Error - GRAM Protocol Error Constants</simpara>
</section>
<section id="ID-c60796a234d35f578606676c401dfc40">
<title>DESCRIPTION</title>
<simpara>The Globus::GRAM::Error module defines symbolic names for the Error
constants in the GRAM Protocol.</simpara>
<simpara>The Globus::GRAM::Error module methods return an object consisting of an
integer erorr code, and (optionally) a string explaining the error.</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">$error = new Globus::GRAM::Error($number, $string);</emphasis>
</term>
<listitem>
<simpara>
     Create a new error object with the given error number and string
description. This is called by the error-specific factory methods
described below.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error&#8594;string()</emphasis>
</term>
<listitem>
<simpara>
     Return the error string associated with a Globus::GRAM::Error object.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error&#8594;value()</emphasis>
</term>
<listitem>
<simpara>
     Return the integer error code associated with a Globus::GRAM::Error
object.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::PARAMETER_NOT_SUPPORTED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new PARAMETER_NOT_SUPPORTED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_REQUEST()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_REQUEST GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::NO_RESOURCES()</emphasis>
</term>
<listitem>
<simpara>
     Create a new NO_RESOURCES GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::BAD_DIRECTORY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new BAD_DIRECTORY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::EXECUTABLE_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new EXECUTABLE_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INSUFFICIENT_FUNDS()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INSUFFICIENT_FUNDS GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::AUTHORIZATION()</emphasis>
</term>
<listitem>
<simpara>
     Create a new AUTHORIZATION GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::USER_CANCELLED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new USER_CANCELLED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::SYSTEM_CANCELLED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new SYSTEM_CANCELLED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::PROTOCOL_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new PROTOCOL_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STDIN_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STDIN_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::CONNECTION_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new CONNECTION_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_MAXTIME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_MAXTIME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_COUNT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_COUNT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::NULL_SPECIFICATION_TREE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new NULL_SPECIFICATION_TREE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JM_FAILED_ALLOW_ATTACH()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JM_FAILED_ALLOW_ATTACH GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JOB_EXECUTION_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JOB_EXECUTION_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_PARADYN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_PARADYN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_JOBTYPE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_JOBTYPE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_GRAM_MYJOB()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_GRAM_MYJOB GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::BAD_SCRIPT_ARG_FILE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new BAD_SCRIPT_ARG_FILE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::ARG_FILE_CREATION_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new ARG_FILE_CREATION_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_JOBSTATE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_JOBSTATE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_SCRIPT_REPLY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_SCRIPT_REPLY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_SCRIPT_STATUS()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_SCRIPT_STATUS GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JOBTYPE_NOT_SUPPORTED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::UNIMPLEMENTED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new UNIMPLEMENTED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::TEMP_SCRIPT_FILE_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new TEMP_SCRIPT_FILE_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::USER_PROXY_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new USER_PROXY_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OPENING_USER_PROXY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OPENING_USER_PROXY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JOB_CANCEL_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JOB_CANCEL_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::MALLOC_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new MALLOC_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::DUCT_INIT_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new DUCT_INIT_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::DUCT_LSP_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new DUCT_LSP_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_HOST_COUNT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_HOST_COUNT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::UNSUPPORTED_PARAMETER()</emphasis>
</term>
<listitem>
<simpara>
     Create a new UNSUPPORTED_PARAMETER GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_QUEUE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_QUEUE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_PROJECT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_PROJECT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_EVALUATION_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_EVALUATION_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::BAD_RSL_ENVIRONMENT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new BAD_RSL_ENVIRONMENT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::DRYRUN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new DRYRUN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::ZERO_LENGTH_RSL()</emphasis>
</term>
<listitem>
<simpara>
     Create a new ZERO_LENGTH_RSL GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STAGING_EXECUTABLE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STAGING_EXECUTABLE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STAGING_STDIN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STAGING_STDIN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_JOB_MANAGER_TYPE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_JOB_MANAGER_TYPE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::BAD_ARGUMENTS()</emphasis>
</term>
<listitem>
<simpara>
     Create a new BAD_ARGUMENTS GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::GATEKEEPER_MISCONFIGURED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new GATEKEEPER_MISCONFIGURED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::BAD_RSL()</emphasis>
</term>
<listitem>
<simpara>
     Create a new BAD_RSL GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::VERSION_MISMATCH()</emphasis>
</term>
<listitem>
<simpara>
     Create a new VERSION_MISMATCH GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_ARGUMENTS()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_ARGUMENTS GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_COUNT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_COUNT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_DIRECTORY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_DIRECTORY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_DRYRUN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_DRYRUN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_ENVIRONMENT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_ENVIRONMENT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_EXECUTABLE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_EXECUTABLE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_HOST_COUNT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_HOST_COUNT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_JOBTYPE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_JOBTYPE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_MAXTIME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_MAXTIME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_MYJOB()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_MYJOB GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_PARADYN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_PARADYN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_PROJECT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_PROJECT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_QUEUE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_QUEUE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_STDERR()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_STDERR GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_STDIN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_STDIN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_STDOUT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_STDOUT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OPENING_JOBMANAGER_SCRIPT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OPENING_JOBMANAGER_SCRIPT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::CREATING_PIPE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new CREATING_PIPE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::FCNTL_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new FCNTL_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STDOUT_FILENAME_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STDOUT_FILENAME_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STDERR_FILENAME_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STDERR_FILENAME_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::FORKING_EXECUTABLE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new FORKING_EXECUTABLE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::EXECUTABLE_PERMISSIONS()</emphasis>
</term>
<listitem>
<simpara>
     Create a new EXECUTABLE_PERMISSIONS GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OPENING_STDOUT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OPENING_STDOUT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OPENING_STDERR()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OPENING_STDERR GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OPENING_CACHE_USER_PROXY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OPENING_CACHE_USER_PROXY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OPENING_CACHE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OPENING_CACHE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INSERTING_CLIENT_CONTACT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INSERTING_CLIENT_CONTACT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::CLIENT_CONTACT_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new CLIENT_CONTACT_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::CONTACTING_JOB_MANAGER()</emphasis>
</term>
<listitem>
<simpara>
     Create a new CONTACTING_JOB_MANAGER GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_JOB_CONTACT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_JOB_CONTACT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::UNDEFINED_EXE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new UNDEFINED_EXE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::CONDOR_ARCH()</emphasis>
</term>
<listitem>
<simpara>
     Create a new CONDOR_ARCH GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::CONDOR_OS()</emphasis>
</term>
<listitem>
<simpara>
     Create a new CONDOR_OS GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_MIN_MEMORY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_MIN_MEMORY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_MAX_MEMORY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_MAX_MEMORY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_MIN_MEMORY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_MIN_MEMORY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_MAX_MEMORY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_MAX_MEMORY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::HTTP_FRAME_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new HTTP_FRAME_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::HTTP_UNFRAME_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new HTTP_UNFRAME_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::HTTP_PACK_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new HTTP_PACK_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::HTTP_UNPACK_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new HTTP_UNPACK_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_JOB_QUERY()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_JOB_QUERY GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::SERVICE_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new SERVICE_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JOB_QUERY_DENIAL()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JOB_QUERY_DENIAL GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::CALLBACK_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new CALLBACK_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::BAD_GATEKEEPER_CONTACT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new BAD_GATEKEEPER_CONTACT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::POE_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new POE_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::MPIRUN_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new MPIRUN_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_START_TIME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_START_TIME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_RESERVATION_HANDLE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_RESERVATION_HANDLE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_MAX_WALL_TIME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_MAX_WALL_TIME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_MAX_WALL_TIME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_MAX_WALL_TIME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_MAX_CPU_TIME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_MAX_CPU_TIME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_MAX_CPU_TIME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_MAX_CPU_TIME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JM_SCRIPT_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JM_SCRIPT_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JM_SCRIPT_PERMISSIONS()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JM_SCRIPT_PERMISSIONS GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::SIGNALING_JOB()</emphasis>
</term>
<listitem>
<simpara>
     Create a new SIGNALING_JOB GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::UNKNOWN_SIGNAL_TYPE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new UNKNOWN_SIGNAL_TYPE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::GETTING_JOBID()</emphasis>
</term>
<listitem>
<simpara>
     Create a new GETTING_JOBID GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::WAITING_FOR_COMMIT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new WAITING_FOR_COMMIT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::COMMIT_TIMED_OUT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new COMMIT_TIMED_OUT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_SAVE_STATE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_SAVE_STATE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_RESTART()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_RESTART GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_TWO_PHASE_COMMIT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_TWO_PHASE_COMMIT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_TWO_PHASE_COMMIT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_TWO_PHASE_COMMIT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_STDOUT_POSITION()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_STDOUT_POSITION GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_STDOUT_POSITION()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_STDOUT_POSITION GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_STDERR_POSITION()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_STDERR_POSITION GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_STDERR_POSITION()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_STDERR_POSITION GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RESTART_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RESTART_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::NO_STATE_FILE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new NO_STATE_FILE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::READING_STATE_FILE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new READING_STATE_FILE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::WRITING_STATE_FILE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new WRITING_STATE_FILE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OLD_JM_ALIVE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OLD_JM_ALIVE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::TTL_EXPIRED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new TTL_EXPIRED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::SUBMIT_UNKNOWN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new SUBMIT_UNKNOWN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_REMOTE_IO_URL()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_REMOTE_IO_URL GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::WRITING_REMOTE_IO_URL()</emphasis>
</term>
<listitem>
<simpara>
     Create a new WRITING_REMOTE_IO_URL GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STDIO_SIZE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STDIO_SIZE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JM_STOPPED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JM_STOPPED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::USER_PROXY_EXPIRED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new USER_PROXY_EXPIRED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JOB_UNSUBMITTED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JOB_UNSUBMITTED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_COMMIT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_COMMIT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_SCHEDULER_SPECIFIC()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_SCHEDULER_SPECIFIC GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STAGE_IN_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STAGE_IN_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_SCRATCH()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_SCRATCH GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_CACHE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_CACHE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_SUBMIT_ATTRIBUTE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_SUBMIT_ATTRIBUTE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_STDIO_UPDATE_ATTRIBUTE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_STDIO_UPDATE_ATTRIBUTE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_RESTART_ATTRIBUTE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_RESTART_ATTRIBUTE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_FILE_STAGE_IN()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_FILE_STAGE_IN GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_FILE_STAGE_IN_SHARED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_FILE_STAGE_IN_SHARED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_FILE_STAGE_OUT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_FILE_STAGE_OUT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_GASS_CACHE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_GASS_CACHE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_FILE_CLEANUP()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_FILE_CLEANUP GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_SCRATCH()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_SCRATCH GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_SCHEDULER_SPECIFIC()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_SCHEDULER_SPECIFIC GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::UNDEFINED_ATTRIBUTE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new UNDEFINED_ATTRIBUTE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_CACHE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_CACHE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_SAVE_STATE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_SAVE_STATE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::OPENING_VALIDATION_FILE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new OPENING_VALIDATION_FILE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::READING_VALIDATION_FILE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new READING_VALIDATION_FILE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_PROXY_TIMEOUT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_PROXY_TIMEOUT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_PROXY_TIMEOUT()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_PROXY_TIMEOUT GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STAGE_OUT_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STAGE_OUT_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::JOB_CONTACT_NOT_FOUND()</emphasis>
</term>
<listitem>
<simpara>
     Create a new JOB_CONTACT_NOT_FOUND GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::DELEGATION_FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new DELEGATION_FAILED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::LOCKING_STATE_LOCK_FILE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new LOCKING_STATE_LOCK_FILE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_ATTR()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_ATTR GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::NULL_PARAMETER()</emphasis>
</term>
<listitem>
<simpara>
     Create a new NULL_PARAMETER GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::STILL_STREAMING()</emphasis>
</term>
<listitem>
<simpara>
     Create a new STILL_STREAMING GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::AUTHORIZATION_DENIED()</emphasis>
</term>
<listitem>
<simpara>
     Create a new AUTHORIZATION_DENIED GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::AUTHORIZATION_SYSTEM_FAILURE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new AUTHORIZATION_SYSTEM_FAILURE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::AUTHORIZATION_DENIED_JOB_ID()</emphasis>
</term>
<listitem>
<simpara>
     Create a new AUTHORIZATION_DENIED_JOB_ID GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::AUTHORIZATION_DENIED_EXECUTABLE()</emphasis>
</term>
<listitem>
<simpara>
     Create a new AUTHORIZATION_DENIED_EXECUTABLE GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::RSL_USER_NAME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new RSL_USER_NAME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::INVALID_USER_NAME()</emphasis>
</term>
<listitem>
<simpara>
     Create a new INVALID_USER_NAME GRAM error.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$error = Globus::GRAM::Error::LAST()</emphasis>
</term>
<listitem>
<simpara>
     Create a new LAST GRAM error.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="Globus::GRAM::JobDescription">
<title>GLOBUS::GRAM::JOBDESCRIPTION(3pm)</title>
<section id="_name_2">
<title>NAME</title>
<simpara>Globus::GRAM::JobDescription - GRAM Job Description</simpara>
</section>
<section id="_name_3">
<title>NAME</title>
<literallayout class="monospaced">-</literallayout>
</section>
<section id="ID-0438a8e2a51c2613b43085fb482b3c22">
<title>DESCRIPTION</title>
<simpara>This object contains the parameters of a job request in a simple object
wrapper. The object may be queried to determine the value of any RSL
parameter, may be updated with new parameters, and may be saved in the
filesystem for later use.</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">new Globus::GRAM::JobDescription(</emphasis>$filename<emphasis role="strong">)</emphasis>
</term>
<listitem>
<simpara>
     A JobDescription is constructed from a file consisting of a Perl hash of
parameter &#8658; array mappings. Every value in the Job Description is
stored internally as an array, even single literals, similar to the way
an RSL tree is parsed in C. An example of such a file is
</simpara>
<screen>$description =
{
    executable  =&gt; [ '/bin/echo' ],
    arguments   =&gt; [ 'hello', 'world' ],
    environment =&gt; [
                       [
                           'GLOBUS_GRAM_JOB_CONTACT',
                           'https://globus.org:1234/2345/4332'
                       ]
                   ]
};</screen>
<simpara>which corresponds to the rsl fragment</simpara>
<screen>&amp;(executable  = /bin/echo)
 (arguments   = hello world)
 (environment =
     (GLOBUS_GRAM_JOB_CONTACT 'https://globus.org:1234/2345/4332')
 )</screen>
<simpara>When the library_path RSL attribute is specified, this object modifies
the environment RSL attribute value to append its value to any system
specific variables.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$description&#8594;</emphasis>add<emphasis role="strong">(<emphasis>name</emphasis>, </emphasis>$value<emphasis role="strong">);</emphasis>
</term>
<listitem>
<simpara>
     Add a parameter to a job description. The parameter will be normalized
internally so that the access methods described below will work with
this new parameter. As an example,
</simpara>
<screen>$description-&gt;add('new_attribute', $new_value)</screen>
<simpara>will create a new attribute in the JobDescription, which can be accessed
by calling the <emphasis role="strong">$description-</emphasis>new_attribute&gt;() method.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis role="strong">*$value</emphasis> $description&#8594;<emphasis role="strong">get</emphasis>(<emphasis>name</emphasis>);</emphasis>*
</term>
<listitem>
<simpara>
     Get a parameter from a job description. As an example,
</simpara>
<screen>$description-&gt;get('attribute')</screen>
<simpara>will return the appropriate attribute in the JobDescription by name.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$description&#8594;</emphasis>save<emphasis role="strong">([$filename])</emphasis>
</term>
<listitem>
<simpara>
     Save the JobDescription, including any added parameters, to the file
named by $filename if present, or replacing the file used in
constructing the object.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$description&#8594;</emphasis>print_recursive<emphasis role="strong">($file_handle)</emphasis>
</term>
<listitem>
<simpara>
     Write the value of the job description object to the file handle
specified in the argument list.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$description&#8594;</emphasis>parameter<emphasis role="strong">()</emphasis>
</term>
<listitem>
<simpara>
     For any parameter defined in the JobDescription can be accessed by
calling the method named by the parameter. The method names are
automatically created when the JobDescription is created, and may be
invoked with arbitrary SillyCaps or underscores. That is, the parameter
gram_myjob may be accessed by the GramMyJob, grammyjob, or gram_my_job
method names (and others).
</simpara>
<simpara>If the attributes does not in this object, then undef will be returned.</simpara>
<simpara>In a list context, this returns the list of values associated with an
attribute.</simpara>
<simpara>In a scalar context, if the attribute&#8217;s value consist of a single
literal, then that literal will be returned, otherwise undef will be
returned.</simpara>
<simpara>For example, from a JobDescription called $d constructed from a
description file containing</simpara>
<screen>{
    executable =&gt; [ '/bin/echo' ],
    arguments  =&gt; [ 'hello', 'world' ]
}</screen>
<simpara>The following will hold:</simpara>
<screen>$executable = $d-&gt;executable()    # '/bin/echo'
$arguments = $d-&gt;arguments()      # undef
@executable = $d-&gt;executable()    # ('/bin/echo')
@arguments = $d-&gt;arguments()      # ('hello', 'world')
$not_present = $d-&gt;not_present()  # undef
@not_present = $d-&gt;not_present()  # ()</screen>
<simpara>To test for existence of a value:</simpara>
<screen>@not_present = $d-&gt;not_present()
print "Not defined\n" if(!defined($not_present[0]));</screen>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="Globus::GRAM::JobManager">
<title>GLOBUS::GRAM::JOBMANAGER(3pm)</title>
<section id="_name_4">
<title>NAME</title>
<simpara>Globus::GRAM::JobManager - Base class for all Job Manager scripts</simpara>
</section>
<section id="_name_5">
<title>NAME</title>
<literallayout class="monospaced">-</literallayout>
</section>
<section id="ID-e96f19759006b55f2a0d9c05142531b8">
<title>DESCRIPTION</title>
<simpara>The Globus::GRAM::JobManager module implements the base behavior for a
Job Manager script interface. Scheduler-specific job manager scripts
must inherit from this module in order to be used by the job manager.</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">$manager = Globus::GRAM::JobManager&#8594;new($JobDescription)</emphasis>
</term>
<listitem>
<simpara>
     Each Globus::GRAM::JobManager object is created by calling the
constructor with a single argument, a Globus::GRAM::JobDescription
object containing the information about the job request which the script
will be modifying. Modules which subclass Globus::GRAM::JobManager MUST
call the super-class&#8217;s constructor, as in this code fragment:
</simpara>
<screen>my $proto = shift;
my $class = ref($proto) || $proto;
my $self = $class-&gt;SUPER::new(@_);

bless $self, $class;</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;log($string)</emphasis>
</term>
<listitem>
<simpara>
     Log a message to the job manager log file. The message is preceded by a
timestamp.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;nfssync($object,$create)</emphasis>
</term>
<listitem>
<simpara>
     Send an NFS update by touching the file (or directory) in question. If
the $create is true, a file will be created. If it is false, the $object
will not be created.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;respond($message)</emphasis>
</term>
<listitem>
<simpara>
     Send a response to the job manager program. The response may either be a
hash reference consisting of a hash of (variable, value) pairs, which
will be returned to the job manager, or an already formatted string.
This only needs to be directly called by a job manager implementation
when the script wants to send a partial response while processing one of
the scheduler interface methods (for example, to indicate that a file
has been staged).
</simpara>
<simpara>The valid keys for a response are defined in the RESPONSES section.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;submit()</emphasis>
</term>
<listitem>
<simpara>
     Submit a job request to the scheduler. The default implementation
returns with the Globus::GRAM::Error::UNIMPLEMENTED error. Scheduler
specific subclasses should reimplement this method to submit the job to
the scheduler.
</simpara>
<simpara>A scheduler which implements this method should return a hash reference
containing a scheduler-specific job identifier as the value of the
hash&#8217;s JOB_ID key, and optionally, the a GRAM job state as the value of
the hash&#8217;s JOB_STATE key if the job submission was successful; otherwise
a Globus::GRAM::Error value should be returned. The job state values are
defined in the Globus::GRAM::JobState module. The job parameters (as
found in the job rsl) are defined in Globus::GRAM::Jobdescription object</simpara>
<simpara>For example:</simpara>
<screen>return {JOB_STATE =&gt; Globus::GRAM::JobState::PENDING,
        JOB_ID =&gt; $job_id};</screen>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;poll()</emphasis>
</term>
<listitem>
<simpara>
     Poll a job&#8217;s status. The default implementation returns with the
Globus::GRAM::Error::UNIMPLEMENTED error. Scheduler specific subclasses
should reimplement this method to poll the scheduler.
</simpara>
<simpara>A scheduler which implements this method should return a hash reference
containing the JOB_STATE value. The job&#8217;s ID can be accessed by calling</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;cancel()</emphasis>
</term>
<listitem>
<simpara>
     Cancel a job. The default implementation returns with the
Globus::GRAM::Error::UNIMPLEMENTED error. Scheduler specific subclasses
should reimplement this method to remove the job from the scheduler.
</simpara>
<simpara>A scheduler which implements this method should return a hash reference
containing the JOB_STATE value. The job&#8217;s ID can be accessed by calling</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;signal()</emphasis>
</term>
<listitem>
<simpara>
     Signal a job. The default implementation returns with the
Globus::GRAM::Error::UNIMPLEMENTED error. Scheduler specific subclasses
should reimplement this method to remove the job from the scheduler. The
JobManager module can determine the job&#8217;s ID, the signal number, and the
(optional) signal arguments from the Job Description by calling it&#8217;s
job_id(), signal(), and and signal_arg() methods, respectively.
</simpara>
<simpara>Depending on the signal, it may be appropriate for the JobManager object
to return a hash reference containing a JOB_STATE update.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;make_scratchdir()</emphasis>
</term>
<listitem>
<simpara>
     Create a scratch directory for a job. The scratch directory location is
based on the JobDescription&#8217;s scratch_dir_base() and scratch_dir()
methods.
</simpara>
<simpara>If the scratch_dir() value is a relative path, then a directory will be
created as a subdirectory of scratch_dir_base()/scratch_dir(),
otherwise, it will be created as a subdirectory of scratch_dir(). This
method will return a hash reference containing mapping SCRATCH_DIR to
the absolute path of newly created scratch directory if successful.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;remove_scratchdir()</emphasis>
</term>
<listitem>
<simpara>
     Delete a job&#8217;s scratch directory. All files and subdirectories of the
JobDescription&#8217;s scratch_directory() will be deleted.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;file_cleanup()</emphasis>
</term>
<listitem>
<simpara>
     Delete some job-related files. All files listed in the JobDescription&#8217;s
file_cleanup() array will be deleted.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;rewrite_urls()</emphasis>
</term>
<listitem>
<simpara>
     Looks up URLs listed in the JobDescription&#8217;s stdin() and executable(),
and replaces them with paths to locally cached copies.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;stage_in()</emphasis>
</term>
<listitem>
<simpara>
     Stage input files need for the job from remote storage. The files to be
staged are defined by the array of [URL, path] pairs in the job
description&#8217;s file_stage_in() and file_stage_in_shared() methods. The
Globus::GRAM::JobManager module provides an implementation of this
functionality using the globus-url-copy and globus-gass-cache programs.
Files which are staged in are not automatically removed when the job
terminates.
</simpara>
<simpara>This function returns intermediate responses using the
Globus::GRAM::JobManager::response() method to let the job manager know
when each individual file has been staged.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;stage_out()</emphasis>
</term>
<listitem>
<simpara>
     Stage output files generated by this job to remote storage. The files to
be staged are defined by the array of [URL, destination] pairs in the
job description&#8217;s file_stage_out() method. The Globus::GRAM::JobManager
module provides an implementation of this functionality using the
globus-url-copy program. Files which are staged out are not removed by
this method.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;cache_cleanup()</emphasis>
</term>
<listitem>
<simpara>
     Clean up cache references in the GASS which match this job&#8217;s cache tag .
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;remote_io_file_create()</emphasis>
</term>
<listitem>
<simpara>
     Create the remote I/O file in the job dir which will contain the
remote_io_url RSL attribute&#8217;s value.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;proxy_relocate()</emphasis>
</term>
<listitem>
<simpara>
     Relocate the delegated proxy for job execution. Job Managers need to
override the default if they intend to relocate the proxy into some
common file system other than the cache. The job manager program does
not depend on the new location of the proxy. Job Manager modules must
not remove the default proxy.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$hashref = $manager&#8594;proxy_update();</emphasis>
</term>
<term>
<emphasis role="strong">$manager&#8594;append_path($ref, $var, $path)</emphasis>
</term>
<listitem>
<simpara>
     Append $path to the value of $ref&#8594;{$var}, dealing with the case where
$ref&#8594;{$var} is not yet defined.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;pipe_out_cmd(@arg)</emphasis>
</term>
<listitem>
<simpara>
     Create a new process to run the first argument application with the
remaining arguments (which may be empty). No shell metacharacter will be
evaluated, avoiding a shell invocation. Stderr is redirected to
/dev/null and stdout is being captured by the parent process, which is
also the result returned. In list mode, all lines are returned, in
scalar mode, only the first line is being returned. The line termination
character is already cut off. Use this function as more efficient
backticks, if you do not need shell metacharacter evaluation.
</simpara>
<simpara>Caution: This function deviates in two manners from regular backticks.
Firstly, it chomps the line terminator from the output. Secondly, it
returns only the first line in scalar context instead of a multiline
concatinated string. As with regular backticks, the result may be
undefined in scalar context, if no result exists.</simpara>
<simpara>A child error code with an exit code of 127 indicates that the
application could not be run. The scalar result returned by this
function is usually undef&#8217;ed in this case.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">($stder, $rc) = $manager&#8594;pipe_err_cmd(@arg)</emphasis>
</term>
<listitem>
<simpara>
     Create a new process to run the first argument application with the
remaining arguments (which may be empty). No shell metacharacter will be
evaluated, avoiding a shell invocation.
</simpara>
<simpara>This method returns a list of two items, the standard error of the
program, and the exit code of the program. If the error code is 127,
then the application could not be run. Standard output is discarded.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;fork_and_exec_cmd(@arg)</emphasis>
</term>
<listitem>
<simpara>
     Fork off a child to run the first argument in the list. Remaining
arguments will be passed, but shell interpolation is avoided. Signals
SIGINT and SIGQUIT are ignored in the child process. Stdout is appended
to /dev/null, and stderr is dup2 from stdout. The parent waits for the
child to finish, and returns the value for the CHILD_ERROR variable as
result. Use this function as more efficient system() call, if you can do
not need shell metacharacter evaluation.
</simpara>
<simpara>Note that the inability to execute the program will result in a status
code of 127.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;job_dir()</emphasis>
</term>
<listitem>
<simpara>
     Return the temporary directory to store job-related files, which have no
need for file caching.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$manager&#8594;setup_softenv()</emphasis>
</term>
<listitem>
<simpara>
     Either add a line to the specified command script file handle to load
the user&#8217;s default SoftEnv configuration, or create a custom SoftEnv
script and add commands to the specified command script file handle to
load it.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="ID-bcb5fd9dba9a920db0007cc56619dab1">
<title>RESPONSES</title>
<simpara>When returning from a job interface method, or when sending an
intermediate response via the <emphasis role="strong">response</emphasis>() method, the following hash
keys are valid:</simpara>
<itemizedlist>
<listitem>
<simpara>
JOB_STATE**::
     An integer job state value. These are enumerated in the
Globus::GRAM::JobState module.
</simpara>
</listitem>
<listitem>
<simpara>
ERROR**::
     An integer error code. These are enumerated in the Globus::GRAM::Error
module.
</simpara>
</listitem>
<listitem>
<simpara>
JOB_ID<emphasis role="strong">::
     A string containing a job identifier, which can be used to poll, cancel,
or signal a job in progress. This response should only be returned by
the </emphasis>submit** method.
</simpara>
</listitem>
<listitem>
<simpara>
SCRATCH_DIR<emphasis role="strong">::
     A string containing the path to a newly-created scratch directory. This
response should only be returned by the </emphasis>make_scratchdir** method.
</simpara>
</listitem>
<listitem>
<simpara>
STAGED_IN<emphasis role="strong">::
     A string containing the (URL, path) pair for a file which has now been
staged in. This response should only be returned by the </emphasis>stage_in**
method.
</simpara>
</listitem>
<listitem>
<simpara>
STAGED_IN_SHARED<emphasis role="strong">::
     A string containing the (URL, path) pair for a file which has now been
staged in and symlinked from the cache. This response should only be
returned by the </emphasis>stage_in_shared** method.
</simpara>
</listitem>
<listitem>
<simpara>
STAGED_OUT<emphasis role="strong">::
     A string containing the (path, URL) pair for a file which has now been
staged out by the script. This response should only be returned by the
</emphasis>stage_out** method.
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="Globus::GRAM::JobSignal">
<title>GLOBUS::GRAM::JOBSIGNAL(3pm)</title>
<section id="_name_6">
<title>NAME</title>
<simpara>Globus::GRAM::JobSignal - GRAM Protocol JobSignal Constants</simpara>
</section>
<section id="ID-dde2a5ed0f147b3205232afefdde1cf6">
<title>DESCRIPTION</title>
<simpara>The Globus::GRAM::JobSignal module defines symbolic names for the
JobSignal constants in the GRAM Protocol.</simpara>
<screen></screen>
<sidebar>
<screen></screen>
</sidebar>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::CANCEL()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the CANCEL constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::SUSPEND()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the SUSPEND constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::RESUME()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the RESUME constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::PRIORITY()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the PRIORITY constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::COMMIT_REQUEST()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the COMMIT_REQUEST constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::COMMIT_EXTEND()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the COMMIT_EXTEND constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::STDIO_UPDATE()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the STDIO_UPDATE constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::STDIO_SIZE()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the STDIO_SIZE constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::STOP_MANAGER()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the STOP_MANAGER constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::COMMIT_END()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the COMMIT_END constant.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="Globus::GRAM::JobState">
<title>GLOBUS::GRAM::JOBSTATE(3pm)</title>
<section id="_name_7">
<title>NAME</title>
<simpara>Globus::GRAM::JobState - GRAM Protocol JobState Constants</simpara>
</section>
<section id="ID-419977e2b3d9757b513072e147336574">
<title>DESCRIPTION</title>
<simpara>The Globus::GRAM::JobState module defines symbolic names for the
JobState constants in the GRAM Protocol.</simpara>
<screen></screen>
<sidebar>
<screen></screen>
</sidebar>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::PENDING()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the PENDING constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::ACTIVE()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the ACTIVE constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::FAILED()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the FAILED constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::DONE()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the DONE constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::SUSPENDED()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the SUSPENDED constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::UNSUBMITTED()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the UNSUBMITTED constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::STAGE_IN()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the STAGE_IN constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::STAGE_OUT()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the STAGE_OUT constant.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">$value = Globus::GRAM::ALL()</emphasis>
</term>
<listitem>
<simpara>
     Return the value of the ALL constant.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
</section>
</chapter>
<chapter id="gram5-rsl">
<title>RSL Specification v1.1</title>
<simpara>This is a document to specify the existing RSL v1.0 implementation and
interfaces, as they are provided in the GT 6.0 release. This document
serves as a reference, and more introductory text.</simpara>
<simpara>The Globus Resource Specification Language (RSL) provides a common
interchange language to describe resources. The various components of
the Globus Resource Management architecture manipulate RSL strings to
perform their management functions in cooperation with the other
components in the system. The RSL provides the skeletal syntax used to
compose complicated resource descriptions, and the various resource
management components introduce specific <emphasis>'ATTRIBUTE</emphasis>',<emphasis>'VALUE</emphasis>'&gt;
pairings into this common structure. Each attribute in a resource
description serves as a parameter to control the behavior of one or more
components in the resource management system.</simpara>
<section id="gram5-rsl-syntax-overview">
<title>RSL Syntax Overview</title>
<simpara>The core syntax of the RSL syntax is the <emphasis role="strong">relation</emphasis>. Relations
associate an attribute name with a value, eg the relation
<literal>executable=a.out</literal> provides the name of an executable in a resource
request. There are two generative syntactic structures in the RSL that
are used to build more complicated resource descriptions out of the
basic relations: <emphasis role="strong">compound requests</emphasis> and <emphasis role="strong">value sequences</emphasis>. In
addition, the RSL syntax includes a facility to both introduce and
dereference string <emphasis role="strong">substitution variables</emphasis>.</simpara>
<simpara>The simplest form of compound request, utilized by all resource
management components, is the conjunct-request. The conjuct-request
expresses a conjunction of simple relations or compound requests (like a
boolean AND). The most common conjunct-request in Globus RSL strings is
the combination of multiple relations such as executable name, node
count, executable arguments, and output files for a basic GRAM job
request. Similarly, the core RSL syntax includes a disjunct-request form
to represent disjunctive relations (like a boolean OR). Currently,
however, no resource management component utilizes the disjunct-request
form.</simpara>
<simpara>The last form of compound request is the multi-request. The
multi-request expresses multiple parallel resources that make up a
resource description. The multi-request form differs from the
conjunction and disjunction in two ways: multi-requests introduce new
variable scope, meaning variables defined in one clause of a
multi-request are not visible to the other clauses, and multi-requests
introduce a non-reducible hierarchy to the resource description. Whereas
relations within a conjunct-request can be thought of as <emphasis role="strong">constraints</emphasis>
on the resource being described, the subclauses of a multi-request are
best thought of as individual resource descriptions that together
constitute an abstract resource collection; the same attributes may be
<emphasis role="strong">constrained</emphasis> in different ways in each subclause without causing a
logical contradiction. An example of a contradiction would be to
constrain the <literal>executable</literal> attribute to be two conflicting values
within a conjunction. Currently, however, no resource management
component utilizes the disjunct-request form.</simpara>
<simpara>The simplest form of value in the RSL syntax is the string literal. When
explicitly quoted, literals can contain any character, and many common
literals that don&#8217;t contain special characters can appear without
quotes. Values can also be variable references, in which case the
variable reference is in essence <emphasis role="strong">replaced</emphasis> with the string value
defined for that variable. RSL descriptions can also express
string-concatenation of values, especially useful to construct long
strings out of several variable references. String concatenation is
supported with both an explicit concatenation operator and implicit
concatenation for many idiomatic constructions involving variable
references and literals.</simpara>
<simpara>In addition to the simple value forms given above, the RSL syntax
includes the value sequence to express ordered sets of values. The value
sequence syntax is used primarily for defining variables and for
providing the argument list for a program.</simpara>
</section>
<section id="gram5-rsl-tokenization-overview">
<title>RSL Tokenization Overview</title>
<simpara>Each RSL string consists of a sequence of RSL tokens, whitespace, and
comments. The RSL tokens are either special syntax or regular unquoted
literals, where special syntax contains one or more of the following
listed special characters and unquoted literals are made of sequences of
characters excluding the special characters.</simpara>
<simpara>The complete set of special characters that cannot appear as part of an
unquoted literal is:</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>+</literal> (plus)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&amp;</literal> (ampersand)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>|</literal> (pipe)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>(</literal>(left paren)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>)</literal> (right paren)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>=</literal> (equal)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;</literal> (left angle)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&gt;</literal> (right angle)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>!</literal> (exclamation)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>"</literal> (double quote)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>'</literal> (apostrophe)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>^</literal> (carat)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>#</literal> (pound)
</simpara>
</listitem>
<listitem>
<simpara>
<literal>$</literal> (dollar)
</simpara>
</listitem>
</itemizedlist>
<simpara>These characters can only be used for the special syntactic forms
described in the section and in the section or as within quoted
literals.</simpara>
<simpara>Quoted literals are introduced with the <literal>"</literal> (double quote) or <literal>'</literal>
(single quote/apostrophe) and consist of all the characters up to (but
not including) the next solo double or single quote, respectively. To
escape a quote character within a quoted literal, the appearance of the
quote character twice in a row is converted to a single instance of the
character and the literal continues until the next solo quote character.
For any quoted literal, there is only one possible escape sequence, eg
within a literal delimited by the single quote character only the single
quote character uses the escape notation and the double quote character
can appear without escape.</simpara>
<simpara>Quoted literals can also be introduced with an alternate <emphasis role="strong">user
delimiter</emphasis> notation. User delimited literals are introduced with the
<literal>^</literal> (carat) character followed immediately by a user-provided
delimiter; the literal consists of all the characters after the user&#8217;s
delimiter up to (but not including) the next solo instance of the
delimiter. The delimiter itself may be escaped within the literal by
providing two instances in a row, just as the regular quote delimiters
are escaped in regular quoted literals.</simpara>
<simpara>RSL string comments use a notation similar to comments in the C
programming language. Comments are introduced by the prefix <literal>(*</literal>.
Comments continue to the first terminating suffix <literal>*)</literal> and cannot be
nested. Comments are stripped from the RSL string during processing and
are syntactically equivalent to whitespace.</simpara>
<example>
<title>Quoted Literal Examples</title>
<simpara>Assign the value <literal>Hello. Welcome to "The Grid"</literal> to the attribute
<literal>arguments</literal>, using double-quote as the delimiter and the escaping
sequence.</simpara>
<screen>arguments = "Hello. Welcome to ""The Grid"""</screen>
<simpara>Assign the value <literal>Hello. Welcome to "The Grid"</literal> to the attribute
<literal>arguments</literal> using the single-quote delimiter.</simpara>
<screen>arguments = 'Hello. Welcome to "The Grid'</screen>
<simpara>Assign the value <literal>Hello. Welcome to "The Grid"</literal> to the attribute
<literal>arguments</literal> using a user-defined quoting character <literal>!</literal>.</simpara>
<screen>arguments = ^!Hello. Welcome to "The Grid"!</screen>
</example>
</section>
<section id="gram5-rsl-substitution-semantics">
<title>RSL Substitution Semantics</title>
<simpara>RSL strings can introduce and reference string variables. String
substitution variables are defined in a special relation using the
<literal>rsl_substitution</literal> attribute, and the definitions affect variable
references made in the same conjunct-request (or disjunct-request), as
well as references made within any multi-request nested inside one of
the clauses of the conjunction (or disjunction). Each multi-request
introduces a new variable scope for each subrequest, and variable
definitions do not escape the closest enclosing scope.</simpara>
<simpara>Within any given scope, variable definitions are processed left-to-right
in the resource description. Outermost scopes are processed before inner
scopes, and the definitions in inner scopes augment the inherited
definitions with new and/or updated variable definitions.</simpara>
<simpara>Variable definitions and variable references are processed in a single
pass, with each definition updating the <emphasis role="strong">environment</emphasis> prior to
processing the next definition. The value provided in a variable
definition may include a reference to a previously-defined variable.
References to variables that are not yet provided with definitions in
the standard RSL variable processing order are replaced with an empty
literal string.</simpara>
</section>
<section id="gram5-rsl-attribute-summary">
<title>RSL Attribute Summary</title>
<simpara>The RSL syntax is extensible because it defines structure without too
many keywords. Each Globus resource management component introduces
additional attributes to the set recognized by RSL-aware components, so
it is difficult to provide a complete listing of attributes which might
appear in a resource description. Resource management components are
designed to utilize attributes they recognize and pass unrecongnized
relations through unchanged. This allows powerful compositions of
different resource management functions.</simpara>
<simpara>The following listing summarizes the attribute names utilized by
existing resource management components in the standard Globus release.
Please see the individual component documentation for discussion of the
attribute semantics.</simpara>
<section id="_rsl_5">
<title>RSL(5)</title>
<section id="_name_8">
<title>NAME</title>
<simpara>rsl - GRAM5 RSL Attributes</simpara>
</section>
<section id="_description">
<title>Description</title>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><literal>arguments</literal></emphasis>
</term>
<listitem>
<simpara>
     The command line arguments for the executable. Use quotes, if a space is required in a single argument.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>count</literal></emphasis>
</term>
<listitem>
<simpara>
     The number of executions of the executable. [Default: <literal>1</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>directory</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies the path of the directory the jobmanager will use as the default directory for the requested job. [Default: <literal>$(HOME)</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>dry_run</literal></emphasis>
</term>
<listitem>
<simpara>
     If dryrun = yes then the jobmanager will not submit the job for execution and will return success. [Default: <literal>no</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>environment</literal></emphasis>
</term>
<listitem>
<simpara>
     The environment variables that will be defined for the executable in addition to default set that is given to the job by the jobmanager.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>executable</literal></emphasis>
</term>
<listitem>
<simpara>
     The name of the executable file to run on the remote machine. If the value is a GASS URL, the file is transferred to the remote gass cache before executing the job and removed after the job has terminated.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>expiration</literal></emphasis>
</term>
<listitem>
<simpara>
     Time (in seconds) after a a job fails to receive a two-phase commit end signal before it is cleaned up. [Default: <literal>14400</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>file_clean_up</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies a list of files which will be removed after the job is completed.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>file_stage_in</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies a list of ("remote URL" "local file") pairs which indicate files to be staged to the nodes which will run the job.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>file_stage_in_shared</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies a list of ("remote URL" "local file") pairs which indicate files to be staged into the cache. A symlink from the cache to the "local file" path will be made.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>file_stage_out</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies a list of ("local file" "remote URL") pairs which indicate files to be staged from the job to a GASS-compatible file server.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>gass_cache</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies location to override the GASS cache location.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>gram_my_job</literal></emphasis>
</term>
<listitem>
<simpara>
     Obsolete and ignored. [Default: <literal>collective</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>host_count</literal></emphasis>
</term>
<listitem>
<simpara>
     Only applies to clusters of SMP computers, such as newer IBM SP systems. Defines the number of nodes ("pizza boxes") to distribute the "count" processes across.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>job_type</literal></emphasis>
</term>
<listitem>
<simpara>
     This specifies how the jobmanager should start the job. Possible values are single (even if the count &gt; 1, only start 1 process or thread), multiple (start count processes or threads), mpi (use the appropriate method (e.g. mpirun) to start a program compiled with a vendor-provided MPI library. Program is started with count nodes), and condor (starts condor jobs in the "condor" universe.) [Default: <literal>multiple</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>library_path</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies a list of paths to be appended to the system-specific library path environment variables. [Default: <literal>$(GLOBUS_LOCATION)/lib</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>loglevel</literal></emphasis>
</term>
<listitem>
<simpara>
     Override the default log level for this job. The value of this attribute consists of a combination of the strings FATAL, ERROR, WARN, INFO, DEBUG, TRACE joined by the | character
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>logpattern</literal></emphasis>
</term>
<listitem>
<simpara>
     Override the default log path pattern for this job. The value of this attribute is a string (potentially containing RSL substitutions) that is evaluated to the path to write the log to. If the resulting string contains the string $(DATE) (or any other RSL substitution), it will be reevaluated at log time.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>max_cpu_time</literal></emphasis>
</term>
<listitem>
<simpara>
     Explicitly set the maximum cputime for a single execution of the executable. The units is in minutes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set cputime, then an error will be returned.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>max_memory</literal></emphasis>
</term>
<listitem>
<simpara>
     Explicitly set the maximum amount of memory for a single execution of the executable. The units is in Megabytes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set maxMemory, then an error will be returned.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>max_time</literal></emphasis>
</term>
<listitem>
<simpara>
     The maximum walltime or cputime for a single execution of the executable. Walltime or cputime is selected by the GRAM scheduler being interfaced. The units is in minutes. The value will go through an atoi() conversion in order to get an integer.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>max_wall_time</literal></emphasis>
</term>
<listitem>
<simpara>
     Explicitly set the maximum walltime for a single execution of the executable. The units is in minutes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set walltime, then an error will be returned.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>min_memory</literal></emphasis>
</term>
<listitem>
<simpara>
     Explicitly set the minimum amount of memory for a single execution of the executable. The units is in Megabytes. The value will go through an atoi() conversion in order to get an integer. If the GRAM scheduler cannot set minMemory, then an error will be returned.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>project</literal></emphasis>
</term>
<listitem>
<simpara>
     Target the job to be allocated to a project account as defined by the scheduler at the defined (remote) resource.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>proxy_timeout</literal></emphasis>
</term>
<listitem>
<simpara>
     Obsolete and ignored. Now a job-manager-wide setting.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>queue</literal></emphasis>
</term>
<listitem>
<simpara>
     Target the job to a queue (class) name as defined by the scheduler at the defined (remote) resource.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>remote_io_url</literal></emphasis>
</term>
<listitem>
<simpara>
     Writes the given value (a URL base string) to a file, and adds the path to that file to the environment throught the GLOBUS_REMOTE_IO_URL environment variable. If this is specified as part of a job restart RSL, the job manager will update the file&#8217;s contents. This is intended for jobs that want to access files via GASS, but the URL of the GASS server has changed due to a GASS server restart.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>restart</literal></emphasis>
</term>
<listitem>
<simpara>
     Start a new job manager, but instead of submitting a new job, start managing an existing job. The job manager will search for the job state file created by the original job manager. If it finds the file and successfully reads it, it will become the new manager of the job, sending callbacks on status and streaming stdout/err if appropriate. It will fail if it detects that the old jobmanager is still alive (via a timestamp in the state file). If stdout or stderr was being streamed over the network, new stdout and stderr attributes can be specified in the restart RSL and the jobmanager will stream to the new locations (useful when output is going to a GASS server started by the client that&#8217;s listening on a dynamic port, and the client was restarted). The new job manager will return a new contact string that should be used to communicate with it. If a jobmanager is restarted multiple times, any of the previous contact strings can be given for the restart attribute.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>rsl_substitution</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies a list of values which can be substituted into other rsl attributes' values through the $(SUBSTITUTION) mechanism.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>save_state</literal></emphasis>
</term>
<listitem>
<simpara>
     Causes the jobmanager to save it&#8217;s job state information to a persistent file on disk. If the job manager exits or is suspended, the client can later start up a new job manager which can continue monitoring the job.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>savejobdescription</literal></emphasis>
</term>
<listitem>
<simpara>
     Save a copy of the job description to $HOME [Default: <literal>no</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>scratch_dir</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies the location to create a scratch subdirectory in. A SCRATCH_DIRECTORY RSL substitution will be filled with the name of the directory which is created.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>stderr</literal></emphasis>
</term>
<listitem>
<simpara>
     The name of the remote file to store the standard error from the job. If the value is a GASS URL, the standard error from the job is transferred dynamically during the execution of the job. There are two accepted forms of this value. It can consist of a single destination: stderr = URL, or a sequence of destinations: stderr = (DESTINATION) (DESTINATION). In the latter case, the DESTINATION may itself be a URL or a sequence of an x-gass-cache URL followed by a cache tag. [Default: <literal>/dev/null</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>stderr_position</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies where in the file remote standard error streaming should be restarted from. Must be 0.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>stdin</literal></emphasis>
</term>
<listitem>
<simpara>
     The name of the file to be used as standard input for the executable on the remote machine. If the value is a GASS URL, the file is transferred to the remote gass cache before executing the job and removed after the job has terminated. [Default: <literal>/dev/null</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>stdout</literal></emphasis>
</term>
<listitem>
<simpara>
     The name of the remote file to store the standard output from the job. If the value is a GASS URL, the standard output from the job is transferred dynamically during the execution of the job. There are two accepted forms of this value. It can consist of a single destination: stdout = URL, or a sequence of destinations: stdout = (DESTINATION) (DESTINATION). In the latter case, the DESTINATION may itself be a URL or a sequence of an x-gass-cache URL followed by a cache tag. [Default: <literal>/dev/null</literal>]
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>stdout_position</literal></emphasis>
</term>
<listitem>
<simpara>
     Specifies where in the file remote output streaming should be restarted from. Must be 0.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>two_phase</literal></emphasis>
</term>
<listitem>
<simpara>
     Use a two-phase commit for job submission and completion. The job manager will respond to the initial job request with a WAITING_FOR_COMMIT error. It will then wait for a signal from the client before doing the actual job submission. The integer supplied is the number of seconds the job manager should wait before timing out. If the job manager times out before receiving the commit signal, or if a client issues a cancel signal, the job manager will clean up the job&#8217;s files and exit, sending a callback with the job status as GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED. After the job manager sends a DONE or FAILED callback, it will wait for a commit signal from the client. If it receives one, it cleans up and exits as usual. If it times out and save_state was enabled, it will leave all of the job&#8217;s files in place and exit (assuming the client is down and will attempt a job restart later). The timeoutvalue can be extended via a signal. When one of the following errors occurs, the job manager does not delete the job state file when it exits: GLOBUS_GRAM_PROTOCOL_ERROR_COMMIT_TIMED_OUT, GLOBUS_GRAM_PROTOCOL_ERROR_TTL_EXPIRED, GLOBUS_GRAM_PROTOCOL_ERROR_JM_STOPPED, GLOBUS_GRAM_PROTOCOL_ERROR_USER_PROXY_EXPIRED. In these cases, it can not be restarted, so the job manager will not wait for the commit signal after sending the FAILED callback
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>username</literal></emphasis>
</term>
<listitem>
<simpara>
     Verify that the job is running as this user.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
</section>
<section id="gram5-rsl-examples">
<title>Simple RSL Examples</title>
<simpara>The following are some simple example RSL strings to illustrate
idiomatic usage with existing tools and to make concrete some of the
more interesting cases of tokenization, concatenation, and variable
semantics. These are meant to illustrate the use of the RSL notation
without much regard for the specific details of a particular resource
management component.</simpara>
<simpara>Typical GRAM5 resource descriptions contain at least a few relations in
a conjunction:</simpara>
<example>
<title>GRAM5 Job Request Examples</title>
<simpara>This example shows a conjunct request containing values that are
unquoted literals and ordered sequences of a mix of quoted and unquoted
literals.</simpara>
<screen>(* this is a comment *)
&amp; (executable = a.out (* &lt;-- that is an unquoted literal *))
  (directory  = /home/nobody )
  (arguments  = arg1 "arg 2")
  (count = 1)</screen>
<simpara>This example demonstrates RSL substitutions, which can be used to make
sure a string is used consistently multiple times in a resource
description:</simpara>
<screen>&amp; (rsl_substitution  = (TOPDIR  "/home/nobody")
                       (DATADIR $(TOPDIR)"/data")
                       (EXECDIR $(TOPDIR)/bin) )
  (executable = $(EXECDIR)/a.out
        (* ^-- implicit concatenation *))
  (directory  = $(TOPDIR) )
  (arguments  = $(DATADIR)/file1
        (* ^-- implicit concatenation *)
                $(DATADIR) # /file2
        (* ^-- explicit concatenation *)
                '$(FOO)'            (* &lt;-- a quoted literal *))
  (environment = (DATADIR $(DATADIR)))
  (count = 1)</screen>
<simpara>Performing all variable substitution and removing comments yields an
equivalent RSL string:</simpara>
<screen>&amp; (rsl_substitution  = (TOPDIR "/home/nobody")
                       (DATADIR "/home/nobody/data")
                       (EXECDIR "/home/nobody/bin") )
  (executable = "/home/nobody/bin/a.out" )
  (directory  = "/home/nobody" )
  (arguments  = "/home/nobody/data/file1"
                "/home/nobody/data/file2"
                "$(FOO)" )
  (environment = (DATADIR "/home/nobody/data"))
  (count = 1)</screen>
<simpara>Note in the above variable-substitution example, the variable
substitution definitions are not automatically made a part of the job&#8217;s
environment. And explicit <literal>environment</literal> attribute must be used to add
environment variables for the job. Also note that the third value in the
arguments clause is not a variable reference but only quoted literal
that happens to contain one of the special characters.</simpara>
</example>
</section>
<section id="gram5-rsl-grammar-and-tokenization-rules">
<title>RSL grammar and tokenization rules</title>
<simpara>The following is a modified BNF grammar for the Resource Specification
Language. Lexical rules are provided for the implicit concatenation
sequences in the form of conventional regular expressions; for the
<emphasis role="strong">implicit-concat</emphasis> non-terminal rules, whitespace is not allowed
between juxtaposed non-terminals. Grammar comments are provided in
square brackets in a column to the right of the productions, eg
<literal>[comment]</literal> to help relate productions in the grammar to the
terminology used in the above discussion.</simpara>
<simpara>Regular expressions are provided for the terminal class
<literal>string-literal</literal> and for RSL comments. These regular expression make
use of a common inverted character-class notation, as popularized by the
various <emphasis role="strong"><literal>lex</literal></emphasis> tools. Comments are syntactically equivalent to
whitespace and can only appear where the comment prefix cannot be
mistaken for the trailing part of a multi-character unquoted literal.</simpara>
<table
frame="all"
rowsep="1" colsep="1"
>
<title>RSL Grammar</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"> Production </entry>
<entry align="left" valign="top"> Rule </entry>
<entry align="left" valign="top"> Annotations</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis>specification</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>relation</emphasis><?asciidoc-br?>
| <literal>'+'</literal> <emphasis>spec-list</emphasis><?asciidoc-br?>
| <literal>'&amp;'</literal> <emphasis>spec-list</emphasis><?asciidoc-br?>
| <literal>'|'</literal> <emphasis>spec-list</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>relation<?asciidoc-br?>
multi-request<?asciidoc-br?>
conjunct-request<?asciidoc-br?>
disjunct-request<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>spec-list</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'('</literal>  <emphasis>specification</emphasis> <literal>')'</literal> <emphasis>spec-list</emphasis><?asciidoc-br?>
| <literal>'('</literal> <emphasis>specification</emphasis> <literal>')'</literal></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>relation</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'rsl_substitution'</literal> <literal>'='</literal>  <emphasis>binding-sequence</emphasis><?asciidoc-br?>
| <emphasis>attribute</emphasis> <emphasis>op</emphasis> <emphasis>value-sequence</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Substitution variable definition<?asciidoc-br?>
Attribute binding relation<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>binding-sequence</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>binding</emphasis> <emphasis>binding-sequence</emphasis><?asciidoc-br?>
| <emphasis>binding</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>binding</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'('</literal>  <emphasis>string-literal</emphasis> <emphasis>simple-value</emphasis> <literal>')'</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Substitution variable definition<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>attribute</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>string-literal</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>attribute<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>op</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'='</literal> <?asciidoc-br?>
|<literal>'!='</literal> <?asciidoc-br?>
|<literal>'&gt;'</literal> <?asciidoc-br?>
|<literal>'&gt;='</literal> <?asciidoc-br?>
|<literal>'&lt;'</literal> <?asciidoc-br?>
|<literal>'&lt;='</literal></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>value-sequence</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>value</emphasis> <emphasis>value-sequence</emphasis><?asciidoc-br?>
| <emphasis>value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'('</literal>  <emphasis>value-sequence</emphasis> <literal>')'</literal>  <literal>|</literal>  <emphasis>simple-value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>simple-value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>string-literal</emphasis><?asciidoc-br?>
| <emphasis>simple-value</emphasis> <literal>'#'</literal> <emphasis>simple-value</emphasis><?asciidoc-br?>
| <emphasis>implicit-concat</emphasis><?asciidoc-br?>
| <emphasis>variable-reference</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>String<?asciidoc-br?>
Concatenation<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>variable-reference</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'$('</literal>  <emphasis>string-literal</emphasis> <literal>')'</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Variable Reference<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>implicit-concat</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>(</literal>  <emphasis>unquoted-literal</emphasis> <literal>)? (</literal> <emphasis>implicit-concat-core</emphasis> <literal>)+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Implicit concatenation<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>implicit-concat-core</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>variable-reference</emphasis><?asciidoc-br?>
| <literal>(</literal> <emphasis>variable-reference</emphasis> <literal>) (</literal> <emphasis>unquoted-literal</emphasis> <literal>)</literal></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>string-literal</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>quoted-literal</emphasis><?asciidoc-br?>
| <emphasis>unquoted-literal</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>quoted-literal</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'''</literal> <literal>(([^'])</literal> <?asciidoc-br?>
|<literal>(''''))*</literal> <literal>'''</literal> <?asciidoc-br?>
| <literal>'"'</literal>  <literal>(([^"])</literal>  <literal>|</literal>  <literal>('""')*</literal>  <literal>'"'</literal> <?asciidoc-br?>
| <literal>'^' c(([^c]|(cc))* c</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Single-quote delimiter with
            escaping<?asciidoc-br?>
Double-quote delimiter with
            escaping<?asciidoc-br?>
User defined delimiter <?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>unquoted-literal</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>([^\t\v\n+&amp;|()=&lt;&gt;!"'^#$])+</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Non-special characters<?asciidoc-br?></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>comment</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>'(*'</literal> <literal>(([^*])|('*'[^)]))*</literal> <literal>'*)'</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Comment<?asciidoc-br?></simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</chapter>
<chapter id="gram5-debugging">
<title>Debugging</title>
<simpara>Log output from GRAM5 is a useful tool for debugging issues. GRAM5 can
log to either local files or syslog. See the
<ulink url="../..gram5/admin/index.html#gram5-troubleshooting-admin">Admin
Guide</ulink> for information about how to configure logging.</simpara>
<simpara>In most cases, logging at the <literal>INFO</literal> level will produce enough
information to show progress of most operations. Adding <literal>DEBUG</literal> will
also allow log information from the GRAM LRM scripts.</simpara>
<section id="_basic_debugging_methods">
<title>Basic Debugging Methods</title>
<simpara>The first thing to determine when debugging unexpected failures is to
determine whether the gatekeeper service is running, reachable from the
client, and properly configured.</simpara>
<simpara>First, determine that the gatekeeper is running by using a tool such as
<emphasis role="strong"><literal>telnet</literal></emphasis> to connect to the TCP/IP port that the gatekeeper is
listening on. From the GRAM service node, using a default configuration,
use a command like:</simpara>
<screen>%  telnet localhost 2119
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'</screen>
<simpara>An error message like the following indicates that the gatekeeper
service is not starting:</simpara>
<screen>telnet: connect to address 127.0.0.1: Connection refused
telnet: Unable to connect to remote host</screen>
<simpara>If the telnet command exits immediately, then the gatekeeper service is
being started but not running. Check the gatekeeper log (by default
<literal>$GLOBUS_LOCATION/var/globus-gatekeeper.log</literal>) to see if there is an
error message. A common error is having a missing library path
environment variable in the gatekeeper&#8217;s environment or having a
malformed configuration file. See ) to see if there is an error message.
A common error is having a missing library path environment variable in
the gatekeeper&#8217;s environment or having a malformed configuration file.
See
<ulink url="../..gram5/pi/index.html#gram5-globus-gatekeeper">the<emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis></ulink>
for information on the configuration options.</simpara>
<simpara>The next recommended diagnostic is to run the same telnet command from
the machine which is acting as the GRAM client if it is distinct from
the GRAM service node. Be sure to replace <literal>localhost</literal> with the actual
host name of the GRAM service. Again, check for log entries in the case
of immediate exit or refused connection. If the connection does not
work, then there may be some network connectivity or firewall issues
preventing access.</simpara>
<simpara>Next use a tool like <emphasis role="strong"><literal>globusrun</literal></emphasis> to diagnose whether the client is
authorized to contact the gatekeeper service. This is done by using the
<emphasis>-a</emphasis> command-line option. For example:</simpara>
<screen>%  globusrun -a -r grid.example.org

GRAM Authentication test successful</screen>
<simpara>If you do not get the success message above, then check the gatekeeper
log to see if there is a diagnostic message. A common problem is that
the identity of the client is not in the grid mapfile used by the
gatekeeper.</simpara>
<simpara>The next test is to use the <emphasis>-dryrun</emphasis> option to <emphasis role="strong"><literal>globusrun</literal></emphasis> to
verify that the job manager service is properly configured. To do so,
try the following:</simpara>
<screen>%  globusrun -dryrun -r grid.example.org "&amp;(executable=/bin/sh)"
globus_gram_client_callback_allow successful
Dryrun successful</screen>
<simpara>If you do not get the success message above, first check the error
number in the <ulink url="#gram5-error-codes">GRAM5 Error codes table</ulink> to
determine how to proceed. If the result is unclear, check the job
manager log (default <literal>$HOME/gram_DATE.log</literal>) to see if there are any
further details of the error. ) to see if there are any further details
of the error.</simpara>
<simpara>The final test is to submit a test job to the GRAM5 service and wait for
it to terminate, such as this example shows:</simpara>
<screen>%  globus-job-run grid.example.org /bin/sh -c 'echo "hello, grid"'
hello, grid</screen>
<simpara>If the process appears to hang, it might be that the job manager is
unable to send state callbacks to the client. Check that there are no
firewalls or network issues that would prevent the job manager process
from connecting from the GRAM service node to the client node.</simpara>
</section>
<section id="_advanced_debugging_methods">
<title>Advanced Debugging Methods</title>
<simpara>The methods described in this section are intended for debugging
problems in the GRAM code, not in the user environment.</simpara>
<section id="_debugging_the_job_manager">
<title>Debugging the Job Manager</title>
<simpara>To debug the GRAM5 job manager, run the command located in
<literal>$GLOBUS_LOCATION/etc/grid-services/jobmnager-LRM</literal> (ignoring the first
3 fields). For example:  (ignoring the first 3 fields). For example:</simpara>
<screen>%  $GLOBUS_LOCATION/libexec/globus-job-manager \
    -conf $GLOBUS_LOCATION/etc/globus-job-manager.conf -type fork</screen>
<simpara>When the job manager is started in this way, it will log messages to
standard error and will terminate 60 seconds after its last job has
completed. This only works if there are no job managers running for this
particular user. The job manager can be started in a debugger such as
<emphasis role="strong"><literal>gdb</literal></emphasis> or <emphasis role="strong"><literal>valgrind</literal></emphasis> using a similar command-line.</simpara>
</section>
</section>
</chapter>
<chapter id="gram5-troubleshooting">
<title>Troubleshooting</title>
<simpara>For a list of error codes generated by GRAM5, see
<ulink url="#gram5-error-codes">#gram5-error-codes</ulink>.</simpara>
<section id="gram5-troubleshooting-client">
<title>GRAM Client Troubleshooting</title>
<section id="_credential_problems">
<title>Credential Problems</title>
<simpara>GRAM requires a client certificate and private key in order authenticate
with the GRAM service. If these are not available, the GRAM client will
fail. In typical use, a user will create a temporary proxy certificate
either derived from their identity certificate issued by some
certificate authority, or from a service such as myproxy. If a GRAM
client command returns any error containing the string <literal>GSS Major
Status</literal> you&#8217;ve hit a credential problem. Look at the
<ulink url="../..gsic/user/index.html#security-credential-errors">Troubleshooting
Section</ulink> of the GSI manual for details about how to diagnose and correct
these errors. The  tool with the <emphasis>-p</emphasis> command-line option is especially
helpful for diagnosing some of these types of problems.</simpara>
</section>
<section id="_connection_problems">
<title>Connection Problems</title>
<simpara>There are a few things which can go wrong when trying to contact a GRAM
service. These have slightly different error types which can help
diagnose which problem is occurring.</simpara>
<section id="_invalid_resource_name">
<title>Invalid Resource Name</title>
<simpara>If the hostname or TCP port you are using for a GRAM resource name is
not correct, then the GRAM client will be unable to access the service.
Errors of this type will look like this:</simpara>
<screen>%  globus-job-run grid.example.org/jobmanager-fork /bin/hostname

GRAM Job submission failed because the connection to the server failed (check host and port) (error code 12)</screen>
<simpara>When this occurs, check with the resource administrator for correct
resource naming so that you can contact the service.</simpara>
</section>
<section id="_mutual_authentication_failure">
<title>Mutual Authentication Failure</title>
<simpara>GRAM performs mutual authentication, that is, both the client and
service provide certificates indicating who they are. The service uses
the client&#8217;s identity to map the user to a local unix account. The
client uses the server&#8217;s identity to verify that the service is running
with a host credential. The failure of the client to trust the server&#8217;s
certificate will generate an error message that looks like this:
<literal>globus_gsi_gssapi: Authorization denied: The expected name for the
remote host (<ulink url="mailto:host@alias.example.org">host@alias.example.org</ulink>) does not match the authenticated
name of the remote host (<ulink url="mailto:host@grid.example.org">host@grid.example.org</ulink>). This happens when the
name in the host certificate does not match the information obtained
from DNS and is often a DNS configuration problem.</literal></simpara>
<simpara>This mismatch can happen for a number of reasons: a site administrator
has multiple hosts sharing a certificate, a host has multiple DNS
aliases, and the client is not aware of which name the server is using
for its certificate, or a host&#8217;s name has changed since the certificate
was issued. The remedy for the client, after confirming with the GRAM
administrator that the name after "authenticated name of the remote
host" is the correct certificate name is to use a form of the GRAM
resource name which includes this name. For example, explicitly adding a
name to the abbreviated GRAM contact so that instead of
<literal>alias.example.org</literal>, you would use
<literal>alias.example.org::host@grid.example.org</literal>.</simpara>
</section>
<section id="_certificate_trust_issues">
<title>Certificate Trust Issues</title>
<simpara>Because of the mutual authentication, both GRAM users and services can
hit problems if they do not trust their peer&#8217;s certificate or the
Certificate Authority which issued it. If the client doesn&#8217;t trust the
server&#8217;s certificate, it is easier to diagnose, because the GRAM service
doesn&#8217;t send much information back to the client if it doesn&#8217;t trust it.
However, working with the system administrator to get information from
the GRAM logs will usually fix these problems fairly easily.</simpara>
<simpara>If the service&#8217;s certificate is not trusted, the client will receive a
message like this:</simpara>
<screen>%  globus-job-run grid.example.org /bin/hostname
GRAM Job submission failed because an authentication operation failed
OpenSSL Error: s3_clnt.c:915: in library: SSL routines, function SSL3_GET_SERVER_CERTIFICATE: certificate verify failed
globus_gsi_callback_module: Could not verify credential
globus_gsi_callback_module: Can't get the local trusted CA certificate: Untrusted self-signed certificate in chain with hash bbfccedf</screen>
<simpara>This error indicates that certificate chain from the service certificate
to the client contained a self-signed certificate (usually an indication
that it&#8217;s a CA certificate), which the client doesn&#8217;t trust, and
includes the hash of the certificate name (<literal>bbfccedf</literal> in this case).
If you hit this particular type of error, you should send the
information to the GRAM administrator and determine which CA should be
trusted and what its signing policy is, to determine if you want to add
it to your local set of trust roots.</simpara>
<note>
<simpara>Different versions of OpenSSL produce different hashes for the same
certificate names. If you upgrade a system (or transfer CA certificates
between systems) to a different version of OpenSSL, you may hit this
problem even if you think you have the CA certificate in your trusted
certificate directory. If so, run the
<emphasis role="strong"><literal>globus-update-certificate-dir</literal></emphasis> program to update your hashes.</simpara>
</note>
<simpara>There are other reasons why a certificate might not be trusted (it&#8217;s in
a revoked list, it has expired or was issued in the future, etc). For
more details look at the
<ulink url="../..gsic/user/index.html#gsic-user-troubleshooting">troubleshooting
information</ulink> in the GSI user&#8217;s guide.</simpara>
<simpara>If for some reason the service does not trust your certificate, you&#8217;ll
get a rather cryptic message from GRAM that looks like this:</simpara>
<screen>%  globus-job-run grid.example.org /bin/hostname
GRAM Job submission failed because an authentication operation failed
globus_gsi_gssapi: Unable to verify remote side's credentials
globus_gsi_gssapi: Unable to verify remote side's credentials: Couldn't verify the remote certificate
OpenSSL Error: s3_pkt.c:1086: in library: SSL routines, function SSL3_READ_BYTES: sslv3 alert bad certificate SSL alert number 42
 (error code 7)</screen>
<simpara>To remedy this, consult the GRAM administrator to get information from
the <literal>/var/log/globus-gatekeeper.log</literal> file to determine the reason why
the gatekeeper didn&#8217;t like your certificate. Again it could be CA trust
issues, clock skew, or a revoked certificate. The error in the
gatekeeper log would typically look like the client-side trust issue
above.  file to determine the reason why the gatekeeper didn&#8217;t like your
certificate. Again it could be CA trust issues, clock skew, or a revoked
certificate. The error in the gatekeeper log would typically look like
the client-side trust issue above.</simpara>
</section>
<section id="_authentication_with_the_remote_server_failed">
<title>Authentication with the Remote Server Failed</title>
<simpara>Once the GRAM service has authenticated the client, it maps the client&#8217;s
identity to a local user account using a grid-mapfile or other mapping
service. If this fails, the client will receive a message that looks
like this:</simpara>
<screen>%  globus-job-run grid.example.org /bin/hostname
GRAM Job submission failed because authentication with the remote server failed (error code 7)</screen>
<simpara>To remedy this, consult the system administrator of the GRAM resource to
be added to the authorized user&#8217;s list. Be sure to send your credential
subject name to make it easier for them. To get that information, run
the command <emphasis role="strong"><literal>grid-cert-info -s</literal></emphasis>.</simpara>
</section>
<section id="_unable_to_find_the_requested_service">
<title>Unable to Find the Requested Service</title>
<simpara>Recall that a GRAM resource name includes a component called the
<literal>service name</literal>. The default if not specified is <literal>jobmanager</literal>, but
some sites may not use that name, or have a different LRM name than you
expect. If you specify an incorrect service name, or the default is not
present, you&#8217;ll get an error that looks like this:</simpara>
<screen>%  globus-job-run grid.example.org /bin/hostname
GRAM Job submission failed because the gatekeeper failed to find the requested service (error code 93)</screen>
<simpara>If you get this error, you&#8217;ll need to determine which services are
available on that GRAM resource, either by asking the admin or by
looking at the entries in <literal>/etc/grid-services</literal></simpara>
</section>
<section id="_failed_to_run_the_job_manager">
<title>Failed to Run the Job Manager</title>
<simpara>The GRAM service is split between a priveleged process called the
<literal>globus-gatekeeper</literal> and a non-privileged process called the  and a
non-privileged process called the <literal>globus-job-manager</literal> which runs as a
user process. If the  which runs as a user process. If the
<literal>globus-gatekeeper</literal> is unable to locate the  is unable to locate the
<literal>globus-job-manager</literal> process, then this misconfiguration will show up
like this:  process, then this misconfiguration will show up like this:</simpara>
<screen>%  globus-job-run grid.example.org /bin/hostname
GRAM Job submission failed because the gatekeeper failed to run the job manager (error code 47)</screen>
<simpara>This is an installation mistake, and the administrator of the GRAM
resource must fix this.</simpara>
</section>
</section>
<section id="_jobs_are_hanging">
<title>Jobs are Hanging</title>
<simpara>One problem GRAM users sometimes encounter is that it looks like jobs
submitted to GRAM are not making any progress, even though the local
resource manager thinks they&#8217;ve run. There are a couple of reasons why
this might occur: GRAM is not getting the information it needs from the
local resource manager or the GRAM client is not getting the information
it needs. We&#8217;ll cover diagnosing and handling the latter case in this
document, as the other is an system administrator issue.</simpara>
<simpara>The way <emphasis role="strong"><literal>globus-job-run</literal></emphasis> and <emphasis role="strong"><literal>globusrun</literal></emphasis> determine that jobs
have completed is via GRAM job state callbacks. These are messages sent
by the GRAM service to the client node indicating that something
significant has happened in the lifecycle of the job. If for some reason
the GRAM service can not get those messages to the client, the client
will not be able to detect job state changes.</simpara>
<simpara>In order to determine if this is the case, submit a job using
<emphasis role="strong"><literal>globus-job-submit</literal></emphasis>, and then use the <emphasis role="strong"><literal>globus-job-status</literal></emphasis>
command to see if the job state changes. If it does not, then consult
the GRAM administrator---there might be some problem with the
installation. If it does, then for some reason the callbacks are not
happening. This might be firewall issues or host naming issues.</simpara>
<simpara>The GRAM client sends a "callback contact" to the GRAM service when it
submits a job, in order that it can receive notifications. This contact
is a reference to a https server embedded in the GRAM client which only
handles GRAM state callbacks. As with all web servers, it has a URL
which defines how to contact it, which in this case consists of the
client host name and the service port number. If the host name that is
used is not resolvable (such as a for a laptop with a dynamic address),
then the GRAM service will not be able to contact it. If that&#8217;s the
case, you can set the <literal>GLOBUS_HOSTNAME </literal> environment variable to the
IP address that your client can be reached at, and then submit your
jobs. This will cause GRAM to publish that address instead of what it
thinks the client&#8217;s host name is.</simpara>
<simpara>Another way that the GRAM service would be unable to send job state
updates to a client would be if there&#8217;s a firewall between the service
and the client. If that&#8217;s the case, you might need to set the
<literal>GLOBUS_TCP_PORT_RANGE</literal> environment variable to a comma-separated list
of numbers which represent a range of minimum and maximum TCP port
numbers to listen on. You might have to contact your site administrator
to determine what TCP ports are allowed. If there are none, you can
still use <emphasis role="strong"><literal>globus-job-submit</literal></emphasis> and <emphasis role="strong"><literal>globus-job-status</literal></emphasis> to
track your job&#8217;s state changes, or use another tool like those mentioned
in the <ulink url="../..gram5/user/index.html#gram5-user-client-tools">section
about client tools</ulink>.</simpara>
</section>
<section id="_logs_and_debugging">
<title>Logs and Debugging</title>
<simpara>The GRAM service has a log file which contains information about the job
as it is processed. These logs are located by default in
<literal>/var/log/globus/gram_$USERNAME.log</literal>. There are some different logging
levels available, as . There are some different logging levels
available, as
<ulink url="../..gram5/admin/index.html#gram5-log-levels">described in the GRAM
Adminstrator&#8217;s Guide</ulink>. These can be controlled on a per-job basis by
adding the <literal>loglevel</literal> RSL attribute to your job description. The
default is to log only <literal>FATAL</literal> and <literal>ERROR</literal> messages, but other
levels can sometimes help understand what is going on.</simpara>
</section>
<section id="_diagnosing_lrm_errors">
<title>Diagnosing LRM Errors</title>
<simpara>Sometimes, bugs creep into the LRM adapter scripts. When that occurs,
the GRAM job will usually fail with an error like this:</simpara>
<screen>GRAM Job failed because the job manager detected an invalid script status (error
code 25)</screen>
<simpara>If this occurs, you may have to work with a GRAM administrator to help
debug this problem. One helpful thing you can do when reporting it is to
save the GRAM internal script data so that it can be used outside of the
GRAM service to see what the low-level error looks like. To do this, add
the RSL fragment <literal>(savejobdescription = yes)</literal> to your job request.
This will cause GRAM to leave a file called something like
<literal>$HOME/gram_[0-9]*.pl</literal> in your home directory. You can use this with
the internal tool  in your home directory. You can use this with the
internal tool <literal>/usr/share/globus/globus-job-manager-script.pl</literal> to try
to submit the job to the LRM without using the GRAM service. The command
line  to try to submit the job to the LRM without using the GRAM
service. The command line
<emphasis role="strong"><literal>/usr/share/globus/globus-job-manager-script.pl -m </literal></emphasis> will attempt
to submit the job to the LRM. It will show all the information the LRM
script sends to the GRAM service, which might include some perl-language
error or badly formatted output from the script (which must only output
lines which begin with <literal>GRAM_SCRIPT_</literal>.</simpara>
<simpara>In some extreme cases, the savejobdescription option will not generate a
file. If that&#8217;s the case, pass <literal>/dev/null</literal> as the argument to the  as
the argument to the <emphasis>-f</emphasis> command-line option. The problem is likely a
perl syntax error which will be reached before the job description is
loaded.</simpara>
</section>
<section id="_email_support">
<title>Email Support</title>
<simpara>If all else fails, please send information about your problem to
<ulink url="mailto:gram-user@globus.org">gram-user@globus.org</ulink>. You&#8217;ll have to subscribe to a list before you can
send an e-mail to it. See
<ulink url="http://dev.globus.org/wiki/Mailing%5fLists">here</ulink> for general e-mail
lists and information on how to subscribe to a list and
<ulink url="http://dev.globus.org/wiki/GRAM#Mailing%5fLists">here</ulink> for GRAM specific
lists. Depending on the problem, you may be requested to file a bug
report to the globus project&#8217;s <ulink url="https://globus.atlassian.net">Issue
Tracker</ulink>.</simpara>
</section>
</section>
<section id="gram5-troubleshooting-admin">
<title>Admin Troubleshooting</title>
<section id="_security">
<title>Security</title>
<simpara>GRAM requires a host certificate and private key in order for the
<emphasis role="strong"><literal>globus-gatekeeeper</literal></emphasis> service to run. These are typically located
in <literal>/etc/grid-security/hostcert.pem</literal> and  and
<literal>/etc/grid-security/hostkey.pem</literal>, but the path is configurable in the
, but the path is configurable in the
<ulink url="../..gram5/admin/index.html#gram5-configuring-gatekeeper">gatekeeper
configuration file</ulink>. The key must be protected by file permissions
allowing only the root user to read it.</simpara>
<simpara>GRAM also (by default) uses a <literal>grid-mapfile</literal> to authorize Grid users
as local users. This file is typically located in  to authorize Grid
users as local users. This file is typically located in
<literal>/etc/grid-security/grid-mapfile</literal>, but is configurable in the , but is
configurable in the
<ulink url="../..gram5/admin/index.html#gram5-configuring-gatekeeper">gatekeeper
configuration file</ulink>.</simpara>
<simpara>Problems in either of these configurations will show up in the
gatekeeper log described below. See the <ulink url="">GSI</ulink> documentation for
more detailed information about obtaining and installing host
certificates and maintaining a <literal>grid-mapfile</literal>. .</simpara>
</section>
<section id="_verify_that_services_are_running">
<title>Verify that Services are Running</title>
<simpara>GRAM relies on the <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> program and (in some cases)
the <emphasis role="strong"><literal>globus-scheduler-event-generator</literal></emphasis> programs to process jobs.
If the former is not running, jobs requests will fail with a "connection
refused" error. If the latter is not running, GRAM jobs will appear to
"hang" in the <literal>PENDING</literal> state.</simpara>
<simpara>The <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> is typically started via an init script
installed in <literal>/etc/init.d/globus-gatekeeper</literal>. The command . The
command <emphasis role="strong"><literal>/etc/init.d/globus-gatekeeper status</literal></emphasis> will indicate
whether the service is running. See
<ulink url="../..gram5/admin/index.html#gram5-admin-starting-and-stopping">../..gram5/admin/index.html#gram5-admin-starting-and-stopping</ulink> for
more information about starting and stopping the
<emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> program.</simpara>
<simpara>If the <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> service fails to start, the output of
the command <emphasis role="strong"><literal>globus-gatekeeper -test</literal></emphasis> will output information
describing some types of configuration problems.</simpara>
<simpara>The <emphasis role="strong"><literal>globus-scheduler-event-generator</literal></emphasis> is typically started via an
init script installed in
<literal>/etc/init.d/globus-scheduler-event-generator</literal>. It is only needed when
the LRM-specific "setup-seg" package is installed. The command . It is
only needed when the LRM-specific "setup-seg" package is installed. The
command <emphasis role="strong"><literal>/etc/init.d/globus-scheduler-event-generator status</literal></emphasis> will
indicate whether the service is running. See
<ulink url="../..gram5/admin/index.html#gram5-admin-starting-and-stopping">../..gram5/admin/index.html#gram5-admin-starting-and-stopping</ulink> for
more information about starting and stopping the
<emphasis role="strong"><literal>globus-scheduler-event-generator</literal></emphasis> program.</simpara>
</section>
<section id="_verify_that_lrm_packages_are_installed">
<title>Verify that LRM packages are installed</title>
<simpara>The <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> program starts the
<emphasis role="strong"><literal>globus-job-manager</literal></emphasis> service with different command-line
parameters depending on the LRM being used. Use the command
<emphasis role="strong"><literal>globus-gatekeeper-admin -l</literal></emphasis> to list which LRMs the gatekeeper is
configured to use.</simpara>
<simpara>The <emphasis role="strong"><literal>globus-job-manager-script.pl</literal></emphasis> is the interface between the
GRAM job manager process and the LRM adapter. The command
<emphasis role="strong"><literal>/usr/share/globus/globus-job-manager-script.pl -h</literal></emphasis> will print the
list of available adapters.</simpara>
<screen>%  /usr/share/globus/globus-job-manager-script.pl -h
USAGE: /usr/share/globus/globus-job-manager-script.pl -m MANAGER -f FILE -c COMMAND
Installed managers: condor fork</screen>
<simpara>The <emphasis role="strong"><literal>globus-scheduler-event-generator</literal></emphasis> also uses an LRM-specific
module to generate scheduler events for GRAM to reduce the amount of
resources GRAM uses on the machine where it runs. To determine which
LRMs are installed and configured, use the command
<emphasis role="strong"><literal>globus-scheduler-event-generator-admin -l</literal></emphasis>.</simpara>
<screen>%  globus-scheduler-event-generator-admin -l
fork [DISABLED]</screen>
<simpara>If any of these do not show the LRM you are trying to use, install the
relevant packages related to that LRM and restart the GRAM services. See
the <ulink url="../..gram5/admin/index.html">GRAM Administrator&#8217;s Guide</ulink> for
more information about starting and stopping the GRAM services.</simpara>
</section>
<section id="_verify_that_the_lrm_packages_are_configured">
<title>Verify that the LRM packages are configured</title>
<simpara>All GRAM5 LRM adapters have a configuration file for site
customizations, such as queue names, paths to executables needed to
interface with the LRM, etc. Check that the values in these files are
correct. These files are described in
<ulink url="../..gram5/admin/index.html#gram5-configuring-lrm">../..gram5/admin/index.html#gram5-configuring-lrm</ulink>.</simpara>
</section>
<section id="gram5-troubleshooting-gatekeeper-log">
<title>Check the Gatekeeper Log</title>
<simpara>The <literal>/var/log/globus-gatekeeper.log</literal> file contains information about
service requests from clients, and will be useful when diagnosing
service startup failures, authentication failures, and authorization
failures.  file contains information about service requests from
clients, and will be useful when diagnosing service startup failures,
authentication failures, and authorization failures.</simpara>
<section id="_authorization_failures">
<title>Authorization failures</title>
<simpara>GRAM uses GSI to authenticate client job requests. If there is a problem
with the GSI configuration for your host, or a client is trying to
connect with a certificate signed by a CA your host does not trust, the
job request will fail. This will show up in the log as a "GSS
authentication failure". See the <ulink url="../..gsic/admin/index.html">GSI
Administrator&#8217;s Guide</ulink> for information about diagnosing authentication
failures.</simpara>
</section>
<section id="_gridmap_failures">
<title>Gridmap failures</title>
<simpara>After authentication is complete, GRAM maps the Grid identity to a local
user prior to starting the <emphasis role="strong"><literal>globus-job-manager</literal></emphasis> process. If this
fails, an error will show up in the log as "globus_gss_assist_gridmap()
failed authorization". See the <ulink url="../..gsic/admin/index.html">GSI
Administrator&#8217;s Guide</ulink> for information about managing gridmap files.</simpara>
</section>
</section>
<section id="gram5-troubleshooting-jobmanager-log">
<title>Job Manager Logs</title>
<simpara>A per-user job manager log is typically located in
<literal>/var/log/globus/gram_$USERNAME.log</literal>. This log contains information
from the job manager as it attempts to execute GRAM jobs via a local
resource manager. The logs can be fairly verbose. Sometimes looking for
log entries near those containing the string . This log contains
information from the job manager as it attempts to execute GRAM jobs via
a local resource manager. The logs can be fairly verbose. Sometimes
looking for log entries near those containing the string <literal>level=ERROR</literal>
will show more information about what caused a particular failure.</simpara>
<simpara>Once you&#8217;ve found an error in the log, it is generally useful to find
log entries related to the job which hit that error. There are two job
IDs associated with each job, one a GRAM-specific ID, and one an
LRM-specific ID. To determine the GRAM ID associated with a job, look
for the attribute <literal>gramid</literal> in the log message. Finding that, looking
for all other log messages which contain that <literal>gramid</literal> value will give
a better picture of what the job manager is doing. To determine the
LRM-specific ID, look for a message at <literal>TRACE</literal> level with the matching
GRAM ID found above with the <literal>response</literal> value matching
<literal>GRAM_SCRIPT_JOB_ID:</literal><emphasis>LRM-ID</emphasis>. You can then find follow the state of
the <emphasis>LRM-ID</emphasis> as well as the GRAM ID in the log, and correlate the
<emphasis>LRM-ID</emphasis> information with local resource manager logs and administrative
tools.</simpara>
</section>
<section id="_email_support_2">
<title>Email Support</title>
<simpara>If all else fails, please send information about your problem to
<ulink url="mailto:gram-user@globus.org">gram-user@globus.org</ulink>. You&#8217;ll have to subscribe to a list before you can
send an e-mail to it. See
<ulink url="http://dev.globus.org/wiki/Mailing%5fLists">here</ulink> for general e-mail
lists and information on how to subscribe to a list and
<ulink url="http://dev.globus.org/wiki/GRAM#Mailing%5fLists">here</ulink> for GRAM-specific
lists. Depending on the problem, you may be requested to file a bug
report to the Globus project&#8217;s <ulink url="https://globus.atlassian.net">Issue
Tracker</ulink>.</simpara>
</section>
</section>
</chapter>
<chapter id="gram5-error-codes">
<title>Errors</title>
<table id="gram5-errors-table"
frame="all"
rowsep="1" colsep="1"
>
<title>GRAM5 Error Codes</title>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<thead>
<row>
<entry align="left" valign="top"> Error Code </entry>
<entry align="left" valign="top"> Reason </entry>
<entry align="left" valign="top"> Possible Solutions</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara>one of the RSL parameters is not supported</simpara></entry>
<entry align="left" valign="top"><simpara>Check RSL documentation</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL length is greater than the maximum allowed</simpara></entry>
<entry align="left" valign="top"><simpara>Use RSL substitutions to reduce length of RSL strings</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>an I/O operation failed</simpara></entry>
<entry align="left" valign="top"><simpara>Enable trace logging and report to <ulink url="mailto:gram-dev@globus.org">gram-dev@globus.org</ulink></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>jobmanager unable to set default to the directory requested</simpara></entry>
<entry align="left" valign="top"><simpara>Check that RSL <literal>directory</literal> attribute refers to a directory that exists on the target system.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>5</simpara></entry>
<entry align="left" valign="top"><simpara>the executable does not exist</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>executable</literal> attribute refers to an executable that exists on the target system.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>of an unused INSUFFICIENT_FUNDS</simpara></entry>
<entry align="left" valign="top"><simpara>Unimplemented feature.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>7</simpara></entry>
<entry align="left" valign="top"><simpara>authentication with the remote server failed</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the contact string contains the proper X.509 DN.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>8</simpara></entry>
<entry align="left" valign="top"><simpara>the user cancelled the job</simpara></entry>
<entry align="left" valign="top"><simpara>Don&#8217;t cancel jobs you want to complete.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>the system cancelled the job</simpara></entry>
<entry align="left" valign="top"><simpara>Check RSL requirements such as maximum time and memory are valid for the job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>10</simpara></entry>
<entry align="left" valign="top"><simpara>data transfer to the server failed</simpara></entry>
<entry align="left" valign="top"><simpara>Check gatekeeper and/or job manager logs to see why the process failed.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>11</simpara></entry>
<entry align="left" valign="top"><simpara>the stdin file does not exist</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>stdin</literal> attribute refers to a file that exists on the target system or has a valid ftp, gsiftp, http, or https URL.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>the connection to the server failed (check host and port)</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the service is running on the expected TCP/IP port.
       Check that no firewall prevents contacting that TCP/IP port.
       Check <literal>$GLOBUS_LOCATION/var/globus-gatekeeper.log</literal> for runtme configuration errors.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>13</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>maxtime</emphasis> value is not an integer</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>maxtime</literal> value evaluates to an integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>14</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>count</emphasis> value is not an integer</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>count</literal> value evaluates to an integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>15</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager received an invalid RSL</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL string can be parsed by using <emphasis role="strong"><literal>globusrun -p RSL</literal></emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>16</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed in allowing others to make contact</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>17</simpara></entry>
<entry align="left" valign="top"><simpara>the job failed when the job manager attempted to run it</simpara></entry>
<entry align="left" valign="top"><simpara>Verify that the LRM is configured properly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>18</simpara></entry>
<entry align="left" valign="top"><simpara>an invalid paradyn was specified</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>19</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>jobtype</emphasis> value is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>The RSL <literal>jobtype</literal> attribute is not indicated as supported by the LRM. Valid <literal>jobtype</literal> values are <literal>single</literal>,  <literal>multiple</literal>, <literal>mpi</literal>, and <literal>condor</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>20</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>myjob</emphasis> value is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>21</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to locate an internal script argument file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that <literal>$GLOBUS_LOCATION/libexec/globus-job-manager-script.pl</literal> exists and is executable.
Check that the LRM-specific perl module is located in <literal>$GLOBUS_LOCATION/lib/perl/Globus/GRAM/JobManager/</literal> directory and is valid. The command <emphasis role="strong"><literal>perl -I$GLOBUS_LOCATION/lib/perl $GLOBUS_LOCATION/lib/perl/Globus/GRAM/JobManager/LRM.pm</literal></emphasis> can be used to check if there are any syntax errors in the script.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>22</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to create an internal script argument file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that your home directory is writable and not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>23</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager detected an invalid job state</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager logs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>24</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager detected an invalid script response</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager logs. This is likely a bug in the LRM script.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>25</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager detected an invalid script status</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager logs. This is likely a bug in the LRM script.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>26</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>jobtype</emphasis> value is not supported by this job manager</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>jobtype</literal> attribute is implemented by the LRM script. Note that some job types require configuration</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>27</simpara></entry>
<entry align="left" valign="top"><simpara>unused ERROR_UNIMPLEMENTED</simpara></entry>
<entry align="left" valign="top"><simpara>LRM does not support some feature included in the job request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>28</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to create an internal script submission file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the user&#8217;s home file system is not full. Check job manager log</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>29</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager cannot find the user proxy</simpara></entry>
<entry align="left" valign="top"><simpara>Check that client is delegating a proxy when authenticating with the gatekeeper.
Check that the user&#8217;s home filesystem and the <literal>/tmp</literal> file system are not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>30</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to open the user proxy</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the user&#8217;s home filesystem and the <literal>/tmp</literal> file system are not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>31</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to cancel the job as requested</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the user&#8217;s home filesystem and the <literal>/tmp</literal> file system are not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>32</simpara></entry>
<entry align="left" valign="top"><simpara>system memory allocation failed</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log for details.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>33</simpara></entry>
<entry align="left" valign="top"><simpara>the interprocess job communication initialization failed</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>34</simpara></entry>
<entry align="left" valign="top"><simpara>the interprocess job communication setup failed</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>35</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>host count</emphasis> value is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>host_count</literal> attribute evaluates to an integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>36</simpara></entry>
<entry align="left" valign="top"><simpara>one of the provided RSL parameters is unsupported</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log for details about invalid parameter.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>37</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>queue</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>queue</literal> attribute evaluates to a string that corresponds to an LRM-specific queue name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>38</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>project</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>project</literal> attribute evaluates to a string that corresponds to an LRM-specific project name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>39</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL string includes variables that could not be identified</simpara></entry>
<entry align="left" valign="top"><simpara>Check that all RSL substitutions are defined before being used in the job description.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>40</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>environment</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>environment</literal> attribute contains a sequence of <emphasis>VARIABLE</emphasis> <emphasis>VALUE</emphasis> pairs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>41</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>dryrun</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Remove the RSL <literal>dryrun</literal> attribute from the job description.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>42</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL is invalid (an empty string)</simpara></entry>
<entry align="left" valign="top"><simpara>Include a non-empty RSL string in your job submission request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>43</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to stage the executable</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the file service hosting the executable is reachable from the GRAM5 service node.
Check that the executable exists on the file service node.
Check that there is sufficient disk space in the user&#8217;s home directory on the service node to store the executable.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>44</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to stage the stdin file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the file service hosting the standard input file is reachable from the GRAM5 service node.
Check that the standard input file exists on the file service node.
Check that there is sufficient disk space in the user&#8217;s home directory on the service node to store the standard input file.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>45</simpara></entry>
<entry align="left" valign="top"><simpara>the requested job manager type is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>46</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>arguments</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>47</simpara></entry>
<entry align="left" valign="top"><simpara>the gatekeeper failed to run the job manager</simpara></entry>
<entry align="left" valign="top"><simpara>Check the gatekeeper or job manager logs for more information.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>48</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL could not be properly parsed</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL string can be parsed by using <emphasis role="strong"><literal>globusrun -p RSL</literal></emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>49</simpara></entry>
<entry align="left" valign="top"><simpara>there is a version mismatch between GRAM components</simpara></entry>
<entry align="left" valign="top"><simpara>Ask system administrator to upgrade GRAM service to GRAM2 or GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>50</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>arguments</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>arguments</literal> attribute evaluates to a sequence of strings.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>51</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>count</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>count</literal> attribute evaluates to a positive integer value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>52</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>directory</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>directory</literal> attribute evaluates to a string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>53</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>dryrun</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>dryrun</literal> attribute evaluates to either <literal>yes</literal> or <literal>no</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>54</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>environment</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>environment</literal> attribute evaluates to a sequence of VARIABLE, VALUE pairs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>55</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>executable</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>executable</literal> attribute evaluates to a string value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>56</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>host_count</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>host_count</literal> attribute evaluates to a positive integer value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>57</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>jobtype</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>jobtype</literal> attribute evaluates to one of <literal>single</literal>, <literal>multiple</literal>, <literal>mpi</literal>, or <literal>condor</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>58</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>maxtime</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>maxtime</literal> attribute evaluates to a positive integer value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>59</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>myjob</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>60</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>paradyn</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>61</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>project</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>project</literal> attribute evaluates to a string value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>62</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>queue</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>queue</literal> attribute evaluates to a string value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>63</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>stderr</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>stderr</literal> attribute evaluates to a string value or a sequence of DESTINATION URLs with optional CACHE_TAG string parameters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>64</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>stdin</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>stdin</literal> attribute evaluates to a string value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>65</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>stdout</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>stdout</literal> attribute evaluates to a string value or a sequence of DESTINATION URLs with optional CACHE_TAG string parameters.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>66</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to locate an internal script</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log for more details.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>67</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed on the system call pipe()</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>68</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed on the system call fcntl()</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>69</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to create the temporary stdout filename</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>70</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to create the temporary stderr filename</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>71</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed on the system call fork()</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>72</simpara></entry>
<entry align="left" valign="top"><simpara>the executable file permissions do not allow execution</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>executable</literal> attribute refers to an executable program or script.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>73</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to open stdout</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>stdout</literal> attribute refers to one or more valid destination files or URLs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>74</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to open stderr</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>stderr</literal> attribute refers to one or more valid destination files or URLs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>75</simpara></entry>
<entry align="left" valign="top"><simpara>the cache file could not be opened in order to relocate the user proxy</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the user&#8217;s home directory is writable and not full on the GRAM5 service node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>76</simpara></entry>
<entry align="left" valign="top"><simpara>cannot access cache files in ~/.globus/.gass_cache, check permissions, quota, and disk space</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the user&#8217;s home directory is writable and not full on the GRAM5 service node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>77</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to insert the contact in the client contact list</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>78</simpara></entry>
<entry align="left" valign="top"><simpara>the contact was not found in the job manager&#8217;s client contact list</simpara></entry>
<entry align="left" valign="top"><simpara>Don&#8217;t attempt to unregister callback contacts that are not registered</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>79</simpara></entry>
<entry align="left" valign="top"><simpara>connecting to the job manager failed.  Possible reasons: job terminated, invalid job contact, network problems, &#8230;</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the job manager process is running.
Check that the job manager credential has not expired.
Check that the job manager contact refers to the correct TCP/IP host and port.
Check that the job manager contact is not blocked by a firewall.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>80</simpara></entry>
<entry align="left" valign="top"><simpara>the syntax of the job contact is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check the syntax of job contact string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>81</simpara></entry>
<entry align="left" valign="top"><simpara>the executable parameter in the RSL is undefined</simpara></entry>
<entry align="left" valign="top"><simpara>Include the RSL <literal>executable</literal> in all job requests.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>82</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager service is misconfigured.  condor arch undefined</simpara></entry>
<entry align="left" valign="top"><simpara>Add the <emphasis>-condor-arch</emphasis> to the command-line or configuration file for a job manager configured to use the <literal>condor</literal> LRM.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>83</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager service is misconfigured.  condor os undefined</simpara></entry>
<entry align="left" valign="top"><simpara>Add the <emphasis>-condor-os</emphasis> to the command-line or configuration file for a job manager configured to use the <literal>condor</literal> LRM.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>84</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>min_memory</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>min_memory</literal> attribute evaluates to a positive integer value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>85</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>max_memory</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>max_memory</literal> attribute evaluates to a positive integer value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>86</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>min_memory</emphasis> value is not zero or greater</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>min_memory</literal> attribute evaluates to a positive integer value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>87</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>max_memory</emphasis> value is not zero or greater</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>max_memory</literal> attribute evaluates to a positive integer value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>88</simpara></entry>
<entry align="left" valign="top"><simpara>the creation of a HTTP message failed</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>89</simpara></entry>
<entry align="left" valign="top"><simpara>parsing incoming HTTP message failed</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>90</simpara></entry>
<entry align="left" valign="top"><simpara>the packing of information into a HTTP message failed</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>91</simpara></entry>
<entry align="left" valign="top"><simpara>an incoming HTTP message did not contain the expected information</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>92</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager does not support the service that the client requested</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the client is talking to the correct servce</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>93</simpara></entry>
<entry align="left" valign="top"><simpara>the gatekeeper failed to find the requested service</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>94</simpara></entry>
<entry align="left" valign="top"><simpara>the jobmanager does not accept any new requests (shutting down)</simpara></entry>
<entry align="left" valign="top"><simpara>Execute queries before the job has been cleaned up.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>95</simpara></entry>
<entry align="left" valign="top"><simpara>the client failed to close the listener associated with the callback URL</simpara></entry>
<entry align="left" valign="top"><simpara>Call <literal>globus_gram_client_callback_disallow()</literal> with a valid the callback contact.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>96</simpara></entry>
<entry align="left" valign="top"><simpara>the gatekeeper contact cannot be parsed</simpara></entry>
<entry align="left" valign="top"><simpara>Check the syntax of the gatekeeper contact string you are attempting to contact.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>97</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager could not find the <emphasis>poe</emphasis> command</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>98</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager could not find the <emphasis>mpirun</emphasis> command</simpara></entry>
<entry align="left" valign="top"><simpara>Configure the LRM script with <literal>mpirun</literal> in your path.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>99</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>start_time</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>reservation_handle</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>101</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>max_wall_time</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>max_wall_time</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>102</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>max_wall_time</emphasis> value is not zero or greater</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>max_wall_time</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>103</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>max_cpu_time</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>max_cpu_time</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>104</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>max_cpu_time</emphasis> value is not zero or greater</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>max_cpu_time</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>105</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager is misconfigured, a scheduler script is missing</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the adminstrator has configured the LRM by running its setup script.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>106</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager is misconfigured, a scheduler script has invalid permissions</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the adminstrator has installed the <literal>GLOBUS_LOCATION/libexec/globus-job-manager-script.pl</literal> script.
Check that the file system containing that script allows file execution.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>107</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to signal the job</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>108</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager did not recognize/support the signal type</simpara></entry>
<entry align="left" valign="top"><simpara>Check that your signal operation is using the correct signal constant.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>109</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager failed to get the job id from the local scheduler</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>110</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager is waiting for a commit signal</simpara></entry>
<entry align="left" valign="top"><simpara>Send a two-phase commit signal to the job manager to acknowledge receiving the job contact from the job manager.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>111</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager timed out while waiting for a commit signal</simpara></entry>
<entry align="left" valign="top"><simpara>Send a two-phase commit signal to the job manager to acknowledge receiving the job contact from the job manager.
Increase the two-phase commit time out for your job.
Check that the job manager contact TCP/IP port is reachable from your client.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>112</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>save_state</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>save_state</literal> attribute is set to <literal>yes</literal> or <literal>no</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>113</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>restart</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>restart</literal> attribute evaluates to a string containing a job contact string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>114</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>two_phase</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>two_phase</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>115</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>two_phase</emphasis> value is not zero or greater</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>two_phase</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>116</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>stdout_position</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>117</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>stdout_position</emphasis> value is not zero or greater</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>118</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>stderr_position</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>119</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>stderr_position</emphasis> value is not zero or greater</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>120</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager restart attempt failed</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>121</simpara></entry>
<entry align="left" valign="top"><simpara>the job state file doesn&#8217;t exist</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the job contact you are trying to restart matches one that the job manager returned to you.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>122</simpara></entry>
<entry align="left" valign="top"><simpara>could not read the job state file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the state file directory is not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>123</simpara></entry>
<entry align="left" valign="top"><simpara>could not write the job state file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the state file directory is not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>124</simpara></entry>
<entry align="left" valign="top"><simpara>old job manager is still alive</simpara></entry>
<entry align="left" valign="top"><simpara>Contact the returned job manager contact to manage the job you are trying to restart.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>125</simpara></entry>
<entry align="left" valign="top"><simpara>job manager state file TTL expired</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE in GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>126</simpara></entry>
<entry align="left" valign="top"><simpara>it is unknown if the job was submitted</simpara></entry>
<entry align="left" valign="top"><simpara>Check job manager log.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>127</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>remote_io_url</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>remote_io_url</literal> attribute evaluates to a string value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>128</simpara></entry>
<entry align="left" valign="top"><simpara>could not write the remote io url file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the user&#8217;s home file system on the job manager service node is writable and not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>129</simpara></entry>
<entry align="left" valign="top"><simpara>the standard output/error size is different</simpara></entry>
<entry align="left" valign="top"><simpara>Send a stdio update signal to redirect the job manager output to a new URL</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>130</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager was sent a stop signal (job is still running)</simpara></entry>
<entry align="left" valign="top"><simpara>Submit a restart request to monitor the job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>131</simpara></entry>
<entry align="left" valign="top"><simpara>the user proxy expired (job is still running)</simpara></entry>
<entry align="left" valign="top"><simpara>Generate a new proxy and then submit a restart request to monitor the job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>132</simpara></entry>
<entry align="left" valign="top"><simpara>the job was not submitted by original jobmanager</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM2</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>133</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager is not waiting for that commit signal</simpara></entry>
<entry align="left" valign="top"><simpara>Do not send a commit signal to a job that is not waiting for a commit signal.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>134</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL scheduler specific parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check the LRM-specific documentation to determine what values are legal for the RSL extensions implemented by the LRM.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>135</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager could not stage in a file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the file service hosting the file to stage is reachable from the GRAM5 service node.
Check that the file to stage exists on the file service node.
Check that there is sufficient disk space in the user&#8217;s home directory on the service node to store the file to stage.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>136</simpara></entry>
<entry align="left" valign="top"><simpara>the scratch directory could not be created</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the directory named by the RSL <literal>scratch_dir</literal> attribute exists and is writable.
Check that the directory named by the RSL <literal>scratch_dir</literal> attribute is not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>137</simpara></entry>
<entry align="left" valign="top"><simpara>the provided <emphasis>gass_cache</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>gass_cache</literal> attribute evaluates to a string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>138</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL contains attributes which are not valid for job submission</simpara></entry>
<entry align="left" valign="top"><simpara>Do not use restart- or signal-only RSL attributes when submitting a job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>139</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL contains attributes which are not valid for stdio update</simpara></entry>
<entry align="left" valign="top"><simpara>Do not use submit- or restart-only RSL attributes when sending a stdio update signal to a job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>140</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL contains attributes which are not valid for job restart</simpara></entry>
<entry align="left" valign="top"><simpara>Do not use submit- or signal-only RSL attributes when restarting a job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>141</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>file_stage_in</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>file_stage_in</literal> attribute evaluates to a sequence of SOURCE DESTINATION pairs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>142</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>file_stage_in_shared</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>file_stage_in_shared</literal> attribute evaluates to a sequence of SOURCE DESTINATION pairs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>143</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>file_stage_out</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>file_stage_out</literal> attribute evaluates to a sequence of SOURCE DESTINATION pairs.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>144</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>gass_cache</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>gass_cache</literal> attribute evaluates to a string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>145</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>file_cleanup</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>file_clean_up</literal> attribute evaluates to a sequence of strings.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>146</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>scratch_dir</emphasis> parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>scratch_dir</literal> attribute evaluates to a string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>147</simpara></entry>
<entry align="left" valign="top"><simpara>the provided scheduler-specific RSL parameter is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check the LRM-specific documentation to determine what values are legal for the RSL extensions implemented by the LRM.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>148</simpara></entry>
<entry align="left" valign="top"><simpara>a required RSL attribute was not defined in the RSL spec</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>executable</literal> attribute is present in your job request RSL.
Check that the RSL <literal>restart</literal> attributes is present in your restart RSL.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>149</simpara></entry>
<entry align="left" valign="top"><simpara>the gass_cache attribute points to an invalid cache directory</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>gass_cache</literal> attributes evaluates to a directory that exists or can be created.
Check that the user&#8217;s home file system is writable and not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>150</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>save_state</emphasis> parameter has an invalid value</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>save_state</literal> attribute has a value of <literal>yes</literal> or <literal>no</literal>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>151</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager could not open the RSL attribute validation file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that <literal>$GLOBUS_LOCATION/share/globus_gram_job_manager/globus-gram-job-manager.rvf</literal> is present and readable on the job manager service node.
Check that <literal>$GLOBUS_LOCATION/share/globus_gram_job_manager/</literal><emphasis>LRM</emphasis><literal>.rvf</literal> is readable on the job manager service node if present.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>152</simpara></entry>
<entry align="left" valign="top"><simpara>the  job manager could not read the RSL attribute validation file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that <literal>$GLOBUS_LOCATION/share/globus_gram_job_manager/globus-gram-job-manager.rvf</literal> is valid.
Check that <literal>$GLOBUS_LOCATION/share/globus_gram_job_manager/</literal><emphasis>LRM</emphasis><literal>.rvf</literal> is valid if present.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>153</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>proxy_timeout</emphasis> is invalid</simpara></entry>
<entry align="left" valign="top"><simpara>Check that RSL <literal>proxy_timeout</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>154</simpara></entry>
<entry align="left" valign="top"><simpara>the RSL <emphasis>proxy_timeout</emphasis> value is not greater than zero</simpara></entry>
<entry align="left" valign="top"><simpara>Check that RSL <literal>proxy_timeout</literal> attribute evaluates to a positive integer.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>155</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager could not stage out a file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the source file being staged exists on the job manager service node.
Check that the directory of the destination file being staged exists on the file service node.
Check that the directory of the destination file being staged is writable by the user.
Check that the destination file service is reachable by the job manager service node.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>156</simpara></entry>
<entry align="left" valign="top"><simpara>the job contact string does not match any which the job manager is handling</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the job contact string matches one returned from a job request.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>157</simpara></entry>
<entry align="left" valign="top"><simpara>proxy delegation failed</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the job manager service node trusts the signer of your credential.
Check that you trust the signer of the job manager service node&#8217;s credential.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>158</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager could not lock the state lock file</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the file system holding the job state directory supports POSIX advisory locking.
Check that the job state directory is writable by the user on the service node.
Check that the job state directory is not full.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>159</simpara></entry>
<entry align="left" valign="top"><simpara>an invalid globus_io_clientattr_t was used.</simpara></entry>
<entry align="left" valign="top"><simpara>Check that you have initialized the <literal>globus_io_clientattr_t</literal> attribute prior to using it with the GRAM client API.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>160</simpara></entry>
<entry align="left" valign="top"><simpara>an null parameter was passed to the gram library</simpara></entry>
<entry align="left" valign="top"><simpara>Check that you are passing legal values to all GRAM API calls.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>161</simpara></entry>
<entry align="left" valign="top"><simpara>the job manager is still streaming output</simpara></entry>
<entry align="left" valign="top"><simpara>OBSOLETE IN GRAM5</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>162</simpara></entry>
<entry align="left" valign="top"><simpara>the authorization system denied the request</simpara></entry>
<entry align="left" valign="top"><simpara>Check with your GRAM system administrator to allow a particular certificate to be authorized.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>163</simpara></entry>
<entry align="left" valign="top"><simpara>the authorization system reported a failure</simpara></entry>
<entry align="left" valign="top"><simpara>Check with your system administrator to verify that the authorization system is configured properly.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>164</simpara></entry>
<entry align="left" valign="top"><simpara>the authorization system denied the request - invalid job id</simpara></entry>
<entry align="left" valign="top"><simpara>Check with your system administrator to verify that the authorization system is configured properly.
Use a credential which is authorized to interact with a particular GRAM job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>165</simpara></entry>
<entry align="left" valign="top"><simpara>the authorization system denied the request - not authorized to run the specified executable</simpara></entry>
<entry align="left" valign="top"><simpara>Check with your system administrator to verify that the authorization system is configured properly.
Use a credential which is authorized to interact with a particular GRAM job.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>166</simpara></entry>
<entry align="left" valign="top"><simpara>the provided RSL <emphasis>user_name</emphasis> parameter is invalid.</simpara></entry>
<entry align="left" valign="top"><simpara>Check that the RSL <literal>user_name</literal> attribute evaluates to a string.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>167</simpara></entry>
<entry align="left" valign="top"><simpara>the job is not running in the account named by the <emphasis>user_name</emphasis> parameter.</simpara></entry>
<entry align="left" valign="top"><simpara>Ask with the GRAM system administrator to add an authorization entry to allow your credential to run jobs as the specified user account.</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</chapter>
<chapter id="gram5-developer-protocols">
<title>Semantics and syntax of protocols</title>
<section id="gram5-interface-protocol">
<title>GRAM5 Protocol</title>
<simpara>The GRAM Protocol is used to handle communication between the
Gatekeeper, Job Manager, and GRAM Clients. The protocol is based on a
subset of the HTTP/1.1 protocol, with a small set of message types and
responses sent as the body of the HTTP requests and responses. This
document describes GRAM Protocol version 2 as used by GRAM5. This is
compatible with with the GRAM Protocol parsers in GRAM2 with extensions.</simpara>
<section id="_framing">
<title>Framing</title>
<simpara>GRAM messages are framed in HTTP/1.1 messages. However, only a small
subset of the HTTP specification is used or understood by the GRAM
system. All GRAM requests are HTTP POST messages. Only the following
HTTP headers are understood:</simpara>
<itemizedlist>
<listitem>
<simpara>
Host
</simpara>
</listitem>
<listitem>
<simpara>
Content-Type (set to "application/x-globus-gram" in all cases)
</simpara>
</listitem>
<listitem>
<simpara>
Content-Length
</simpara>
</listitem>
<listitem>
<simpara>
Connection (set to "close" in all HTTP responses)
</simpara>
</listitem>
</itemizedlist>
<simpara>Only the following status codes are supported in response&#8217;s HTTP
Status-Line:</simpara>
<itemizedlist>
<listitem>
<simpara>
200 OK
</simpara>
</listitem>
<listitem>
<simpara>
403 Forbidden
</simpara>
</listitem>
<listitem>
<simpara>
404 Not Found
</simpara>
</listitem>
<listitem>
<simpara>
500 Internal Server Error
</simpara>
</listitem>
<listitem>
<simpara>
400 Bad Request
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_message_format">
<title>Message Format</title>
<simpara>All messages use the carriage return (ASCII value 13) followed by line
feed (ASCII value 10) sequence to delimit lines. In all cases, a blank
line separates the HTTP header from the message body. All
<literal>application/x-globus-gram</literal> message bodies consist of attribute names
followed by a colon, a space, and then the value of the attribute. When
the value may contain a newline or double-quote character, a special
escaping rule is used to encapsulate the complete string. This
encapsulation consists of surrounding the string with double-quotes, and
escaping all double-quote and backslash characters within the string
with a backslash. All other characters are sent without modification.
For example, the string</simpara>
<screen>rsl: &amp;( executable = "/bin/echo" )
 ( arguments = "hello" )</screen>
<simpara>becomes</simpara>
<screen>rsl: "&amp;( executable = \"bin/echo\" )
  (arguments = \"hello\" )"</screen>
<simpara>In GRAM5, protocol extensions are supported in the status update
messages. These extensions are implemented as extra attribute names
<emphasis role="strong">after</emphasis> all of the attributes defined in the messages below. Older
GRAM protocol parsers will ignore those extensions that occur after the
attributes in the messages defined below. In GRAM5, the following
extensions are used:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><literal>exit-code</literal></emphasis>
</term>
<listitem>
<simpara>
     Job exit code. Sent in job state callbacks and in job status replies when the job completes.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>gt3-failure-type</literal></emphasis>
</term>
<listitem>
<simpara>
     Failure detail type for staging errors. Sent in job state callbacks and in job status replies when a job fails.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>gt3-failure-message</literal></emphasis>
</term>
<listitem>
<simpara>
     Failure detail message for more context for errors. Sent in job state callbacks and in job status replies when a job fails.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>gt3-failure-source</literal></emphasis>
</term>
<listitem>
<simpara>
     Failure detail message for the source of a failed file transfer. Sent in job state callbacks and in job status replies when a job fails.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>gt3-failure-destination</literal></emphasis>
</term>
<listitem>
<simpara>
     Failure detail message for the destination of a failed file transfer. Sent in job state callbacks and in job status replies when a job fails.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>version</literal></emphasis>
</term>
<listitem>
<simpara>
     Job manager package version. Sent in all messages from the job manager.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><literal>toolkit-version</literal></emphasis>
</term>
<listitem>
<simpara>
     Toolkit release that the job manager is running. Sent in all messages from the job manager.
</simpara>
</listitem>
</varlistentry>
</variablelist>
<simpara>This is the only form of quoting which <literal>application/x-globus-gram</literal>
messages support. Use of <literal>% HEX HEX</literal> escapes (such as seen in URL
encodings) is not meaningful for this protocol.</simpara>
</section>
<section id="_message_types">
<title>Message Types</title>
<section id="_ping_request">
<title>Ping Request</title>
<simpara>A ping request is used to verify that the gatekeeper is configured
properly to handle a named service. The ping request consists of the
following:</simpara>
<screen>POST ping/job-manager-name HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version</screen>
<simpara>The values of the message-specific strings are</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-manager-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the service to have the gatekeeper check. The service name corresponds to one of the gatekeeper&#8217;s configured grid-services, and is usually of the form "jobmanager-<emphasis>LRM</emphasis>".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the host on which the gatekeeper is running. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string "2".
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_job_request">
<title>Job Request</title>
<simpara>A job request is used to scheduler a job remotely using GRAM. The ping
request consists of the HTTP framing described above with the
request-URI consisting of <emphasis>job-manager-name</emphasis>, where <emphasis>job-manager name</emphasis>
is the name of the service to use to schedule the job. The format of a
job request message consists of the following:</simpara>
<screen>POST job-manager-name[@user-name] HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version
job-state-mask: mask
callback-url: callback-contact
rsl: rsl-description</screen>
<simpara>The values of the emphasized text items are as below:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-manager-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the service to submit the job request to. The service name corresponds to one of the gatekeeper&#8217;s configured grid-services, and is usually of the form jobmanager-<emphasis>LRM</emphasis>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>user-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     Starting with GT4.0, a client may request that a certain account by used by the gatekeeper to start the job manager. This is done optionally by appending the @ symbol and the local user name that the job should be run as to the <emphasis>job-manager-name</emphasis>. If the @ and username are not present, then the first grid map entry will be used. If the client credential is not authorized in the grid map to use the specified account, an authorization error will occur in the gatekeeper.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the host on which the gatekeeper is running. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string <literal>2</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>mask</emphasis></emphasis>
</term>
<listitem>
<simpara>
     An integer representation of the job state mask. This value is obtained from a bitwise-OR of the job state values which the client wishes to receive job status callbacks about. These meanings of the various job state values are defined in the GRAM Protocol API documentation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>callback-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     A https URL which defines a GRAM protocol listener which will receive job state updates. The from a bitwise-OR of the job state values which the client wishes to receive job status callbacks about. The job status update messages are defined below.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>rsl-description</emphasis></emphasis>
</term>
<listitem>
<simpara>
     A quoted string containing the RSL description of the job request.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_status_request">
<title>Status Request</title>
<simpara>A status request is used by a GRAM client to get the current job state
of a running job. This type of message can only be sent to a job
manager&#8217;s job-contact (as returned in the reply to a job request
message). The format of a job request message consists of the following:</simpara>
<screen>POST job-contact HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size
protocol-version: version

"status"</screen>
<simpara>The values of the emphasized text items are as below:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The job contact string returned in a response to a job request message, or determined by querying the MDS system.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the host on which the job manager is running. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string <literal>2</literal>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_callback_register_request">
<title>Callback Register Request</title>
<simpara>A callback register request is used by a GRAM client to register a new
callback contact to receive GRAM job state updates. This type of message
can only be sent to a job manager&#8217;s job-contact (as returned in the
reply to a job request message). The format of a job request message
consists of the following:</simpara>
<screen>POST job-contact HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version
"register mask callback-contact"</screen>
<simpara>The values of the emphasized text items are as below:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The job contact string returned in a response to a job request message, or determined by querying the MDS system.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the host on which the job manager is running. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string <literal>2</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>mask</emphasis></emphasis>
</term>
<listitem>
<simpara>
     An integer representation of the job state mask. This value is obtained from a bitwise-OR of the job state values which the client wishes to receive job status callbacks about. These meanings of the various job state values are defined in the GRAM Protocol API documentation.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>callback-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     A https URL which defines a GRAM protocol listener which will receive job state updates. The from a bitwise-OR of the job state values which the client wishes to receive job status callbacks about. The job status update messages are defined below.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_callback_unregister_request">
<title>Callback Unregister Request</title>
<simpara>A callback unregister request is used by a GRAM client to request that
the job manager no longer send job state updates to the specified
callback contact. This type of message can only be sent to a job
manager&#8217;s job-contact (as returned in the reply to a job request
message). The format of a job request message consists of the following:</simpara>
<screen>POST job-contact HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version
"unregister callback-contact"</screen>
<simpara>The values of the emphasized text items are as below:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The job contact string returned in a response to a job request message, or determined by querying the MDS system.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the host on which the job manager is running. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string "2".
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>callback-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     A https URL which defines a GRAM protocol listener which should no longer receive job state updates. The from a bitwise-OR of the job state values which the client wishes to receive job status callbacks about. The job status update messages are defined @ref globus_gram_protocol_job_state_updates "below".
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_job_cancel_request">
<title>Job Cancel Request</title>
<simpara>A job cancel request is used by a GRAM client to request that the job
manager terminate a job. This type of message can only be sent to a job
manager&#8217;s job-contact (as returned in the reply to a job request
message). The format of a job request message consists of the following:</simpara>
<screen>POST job-contact HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version
"cancel"</screen>
<simpara>The values of the emphasized text items are as below:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The job contact string returned in a response to a job request message, or determined by querying the MDS system.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the host on which the job manager is running. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string <literal>2</literal>.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_job_signal_request">
<title>Job Signal Request</title>
<simpara>A job signal request is used by a GRAM client to request that the job
manager process a signal for a job. The arguments to the various signals
are discussed in the protocol library documentation. The format of a job
request message consists of the following:</simpara>
<screen>POST job-contact HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version
"signal"</screen>
<simpara>The values of the emphasized text items are as below:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The job contact string returned in a response to a job request message, or determined by querying the MDS system.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The name of the host on which the job manager is running. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string <literal>2</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>signal</emphasis></emphasis>
</term>
<listitem>
<simpara>
     A quoted string containing the signal number and its parameters.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_job_state_updates">
<title>Job State Updates</title>
<simpara>A job status update message is sent by the job manager to all registered
callback contacts when the job&#8217;s status changes. The format of the job
status update messages is as follows:</simpara>
<screen>POST callback-contact HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version
job-manager-url: job-contact
status: status-code
failure-code: failure-code</screen>
<simpara>The values of the emphasized text items are as below:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>callback-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The callback contact string registered with the job manager either by being passed as the <emphasis>callback-contact</emphasis> in a job request message or in a callback register message.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>host-name</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The host part of the callback-contact URL. This exists only for compatibility with the HTTP/1.1 protocol.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>message-size</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The length of the content of the message, not including the HTTP/1.1 header.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>version</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The version of the GRAM protocol which is being used. For the protocol defined in this document, the value must be the string <literal>2</literal>.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong"><emphasis>job-contact</emphasis></emphasis>
</term>
<listitem>
<simpara>
     The job contact of the job which has changed states.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_proxy_delegation">
<title>Proxy Delegation</title>
<simpara>A proxy delegation message is sent by the client to the job manager to
initiate a delegation handshake to generate a new proxy credential for
the job manager. This credential is used by the job manager or the job
when making further secured connections. The format of the delegation
message is as follows:</simpara>
<screen>POST callback-contact HTTP/1.1
Host: host-name
Content-Type: application/x-globus-gram
Content-Length: message-size

protocol-version: version
"renew"</screen>
<simpara>If a successful (200) reply is sent in response to this message, then
the client will procede with a GSI delegation handshake. The tokens in
this handshake will be framed with a 4 byte big-endian token length
header. The framed tokens will then be wrapped using the
GLOBUS_IO_SECURE_CHANNEL_MODE_SSL_WRAP wrapping mode. The job manager
will frame response tokens in the same manner. After the job manager
receives its final delegation token, it will respond with another
response message that indicates whether the delegation was processed or
not. This response message is a standard GRAM response message.</simpara>
</section>
<section id="_security_attributes">
<title>Security Attributes</title>
<simpara>The following security attributes are needed to communicate with the
Gatekeeper:</simpara>
<itemizedlist>
<listitem>
<simpara>
Authentication must be done using GSSAPI mutual authentication
</simpara>
</listitem>
<listitem>
<simpara>
Messages must be wrapped with support for the delegation message. When using Globus I/O, this is accomplished by using the the GLOBUS_IO_SECURE_CHANNEL_MODE_GSI_WRAP wrapping mode.
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="gram5-state-model">
<title>Job State Model</title>
<simpara>As the GRAM service processes a job, the job undergoes a series of state
transitions. These states and their meanings follow:</simpara>
<variablelist>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_UNSUBMITTED</literal>
</term>
<listitem>
<simpara>
    Initial job state
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_IN</literal>
</term>
<listitem>
<simpara>
    Job staging in progress
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_PENDING</literal>
</term>
<listitem>
<simpara>
    Job submitted to LRM, awaiting execution
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_ACTIVE</literal>
</term>
<listitem>
<simpara>
    Job executing
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_SUSPENDED</literal>
</term>
<listitem>
<simpara>
    Job made progress executing but is now suspended
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_STAGE_OUT</literal>
</term>
<listitem>
<simpara>
    Job staging in progress after job completed
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_DONE</literal>
</term>
<listitem>
<simpara>
    Job completed successfully
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<literal>GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED</literal>
</term>
<listitem>
<simpara>
    Job was canceled or failed
</simpara>
</listitem>
</varlistentry>
</variablelist>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="GRAM5_states.png" width="75%" scalefit="1" align="center"/>
  </imageobject>
  <textobject><phrase>GRAM5_states.png</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</chapter>
<chapter id="gram5-developer-relateddocs">
<title>Related Documentation</title>
<simpara>No related documentation links have been determined at this time.</simpara>
</chapter>
<chapter id="gram5-developer-internal-components">
<title>Internal Components</title>
<simpara><ulink url="internal-components.html">Internal Components</ulink></simpara>
</chapter>
</part>
</book>
