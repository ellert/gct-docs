<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<book lang="en">
<bookinfo>
    <title>Globus Toolkit 6.0 Key Concepts</title>
</bookinfo>
<chapter id="gridftpKey" xreflabel="GridFTP Key Concepts">
<title>GT 6.0 GridFTP Key Concepts</title>
<simpara>One of the foundational issues in HPC computing is the ability to move
large (multi Gigabyte, and even Terabyte), file-based data sets between
sites. Simple file transfer mechanisms such as FTP and SCP are not
sufficient either from a reliability or performance perspective. GridFTP
extends the standard FTP protocol to provide a high-performance, secure,
reliable protocol for bulk data transfer.</simpara>
<section id="gridftp-key-advantages">
<title>GridFTP Protocol</title>
<simpara>GridFTP is a protocol defined by Global Grid Forum Recommendation
GFD.020, RFC 959, RFC 2228, RFC 2389, and a draft before the IETF FTP
working group. Key features include:</simpara>
<itemizedlist>
<listitem>
<simpara>
Performance - GridFTP protocol supports using parallel TCP streams and multi-node transfers to achieve high performance.
</simpara>
</listitem>
<listitem>
<simpara>
Checkpointing - GridFTP protocol requires that the server send restart markers (checkpoint) to the client.
</simpara>
</listitem>
<listitem>
<simpara>
Third-party transfers - The FTP protocol on which GridFTP is based separates control and data channels, enabling third-party transfers, that is, the transfer of data between two end hosts, mediated by a third host.
</simpara>
</listitem>
<listitem>
<simpara>
Security - Provides strong security on both control and data channels. Control channel is encrypted by default. Data channel is authenticated by default with optional integrity protection and encryption.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="globus-gridftp">
<title>Globus Implementation of GridFTP</title>
<simpara>The GridFTP protocol provides for the secure, robust, fast and efficient
transfer of (especially bulk) data. The Globus Toolkit provides the most
commonly used implementation of that protocol, though others do exist
(primarily tied to proprietary internal systems).</simpara>
<simpara>The Globus Toolkit provides:</simpara>
<itemizedlist>
<listitem>
<simpara>
a server implementation called <literal>globus-gridftp-server</literal>,
</simpara>
</listitem>
<listitem>
<simpara>
a scriptable command line client called <literal>globus-url-copy</literal>, and
</simpara>
</listitem>
<listitem>
<simpara>
a set of development libraries for custom clients.
</simpara>
</listitem>
</itemizedlist>
<simpara>While the Globus Toolkit does not provide a client with Graphical User
Interface (GUI), <ulink url="http://www.globusonline.org">Globus Online</ulink> provides a
web GUI for GridFTP data movement.</simpara>
<simpara>Globus GridFTP framework implements all the key features of GridFTP
protocol mentioned above. It supports both Grid Security Infrastructure
(GSI) and SSH for securing the data transfer. Unlike sftp, SSH based
GridFTP supports multiple security options on the data channel -
authentication only, authentication and integrity protection, fully
encrypted. Globus implemention of GridFTP is modular and extensibl. XIO
based Globus GridFTP framework makes it easy to plugin alternate
transport protocols. The Data Storage Interface (DSI) allows for easier
integration with various storage systems. We currently have DSIs for
POSIX filesystems (default) and HPSS. Globus GridFTP has been deployed
at thousands of sites with more than 10 million data transfers per day.</simpara>
</section>
<section id="gridftp-clients">
<title>GridFTP Clients</title>
<simpara><ulink url="http://www.globusonline.org">Globus Online</ulink> is the recommended interface
to move data to and from GridFTP servers. Globus Online provides a web
GUI, command line interface and a REST API for GridFTP data movement. It
provides automatic fault recovery and automatic tuning of optimization
parameters to achieve high performance.</simpara>
<simpara>The Globus Toolkit provides a GridFTP client called <literal>globus-url-copy</literal>,
a command line interface, suitable for scripting. For example, the
following command:</simpara>
<screen>globus-url-copy gsiftp://remote.host.edu/path/to/file file:///path/on/local/host</screen>
<simpara>would transfer a file from a remote host to the locally accessible path
specified in the second URL.</simpara>
<simpara>Finally, if you wish to add access to files stored behind GridFTP
servers, or you need custom client functionality, you can use our very
powerful client library to develop custom client functionality.</simpara>
<simpara>For more information about GridFTP, see:</simpara>
<itemizedlist>
<listitem>
<simpara>
the <ulink url="">documentation</ulink>.
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://www.globus.org/alliance/publications/papers/gridftp%5ffinal.pdf">The Globus Striped GridFTP Framework and Server</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter id="gram5Key" xreflabel="GRAM5 Key Concepts">
<title>GT 6.0 GRAM5 Key Concepts</title>
<simpara>The Globus Toolkit provides GRAM5: a service to submit, monitor, and
cancel jobs on Grid computing resources. In GRAM, a job consists of a
computation and, optionally, file transfer and management operations
related to the computation. Some users, particularly interactive ones,
benefit from accessing output data files as the job is running.
Monitoring consists of querying and/or subscribing for status
information, such as job state changes.
Grid computing resources are typically managed by a local resource
manager which implements allocation and prioritization policies while
optimizing the execution of all submitted jobs for efficiency and
performance according to site policy. GRAM is not a resource scheduler,
but rather a protocol engine for communicating with a range of different
local resource schedulers using a standard message format.</simpara>
<section id="gram5-key-concepts">
<title>Conceptual details</title>
<simpara>A number of concepts underly the purpose and motivation for GRAM. These
concepts are divided into broad categories below.</simpara>
<section id="_targeted_job_types">
<title>Targeted job types</title>
<simpara>GRAM is meant to address a range of jobs where arbitrary programs,
reliable operation, stateful monitoring, credential management, and file
staging are important. GRAM is not meant to serve as a "remote procedure
call" (RPC) interface for applications not requiring many of these
features. Furthermore, its interface model and implementation may be too
costly for such uses. The GRAM5 service protocols and implementation
will always involve multiple round-trips to support these advanced
features that are not required for simple RPC applications.</simpara>
</section>
<section id="_component_architecture">
<title>Component architecture</title>
<simpara>Rather than consisting of a monolithic solution, GRAM is based on a
component architecture at both the protocol and software implementation
levels. This component approach serves as an ideal which shapes the
implementation as well as the abstract design and features.</simpara>
<variablelist>
<varlistentry>
<term>
Service model
</term>
<listitem>
<simpara>
    For GRAM5, the <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> daemon and GSI library are used
    for secure communications and service dispatch.
</simpara>
<simpara>The <emphasis role="strong"><literal>globus-job-manager</literal></emphasis> daemon implements the job management and
file transfer functionality.</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Local Resource Manager Adapters
</term>
<listitem>
<simpara>
    GRAM provides a scripted plug-in architecture to enable extension with
    adapters to control a variety of local resource systems.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_security">
<title>Security</title>
<variablelist>
<varlistentry>
<term>
Secure operation
</term>
<listitem>
<simpara>
    GRAM5 uses SSL-based protocols to establish identity or provide other
    security tokens needed to authorize GRAM5 service requests. Once
    authorized, each instance of the job service runs as a local POSIX user.
    GRAM5 restricts job monitoring and management operations to those who are
    authorized by the local site policy.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Local system protection domains
</term>
<listitem>
<simpara>
    To protect users from each other, the GRAM5 job manager and the jobs it
    starts are executed in separate local security contexts. Additionally, GRAM
    mechanisms used to interact with the local resource are designed to
    minimize the privileges required and to minimize the risks of service
    malfunction or compromise.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Credential delegation and management
</term>
<listitem>
<simpara>
    A client delegates some of its rights to the GRAM service in order to allow
    it to perform file transfers on behalf of the client and send state
    notifications to registered clients. Additionally, GRAM5 provides per-job
    credentials so that job instances may perform further authentication with
    other services.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
Audit
</term>
<listitem>
<simpara>
    GRAM uses a range of audit and logging techniques to record a history of
    job submissions and critical system operations. These records may be used
    to assist with accounting functions as well as to further mitigate risks
    from abuse or malfunction.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
</section>
<section id="gram5-approach" xreflabel="GRAM5 Approach">
<title>GT 6.0 GRAM5 Approach</title>
<section id="gram5-approach-intro">
<title>Introduction</title>
<simpara>The GRAM5 software implements a solution to the job-management problem
described above. This solution is specific to operating systems
following the POSIX programming and security model.</simpara>
</section>
<section id="gram5-approach-approach">
<title>Component architecture approach</title>
<simpara>GRAM5&#8217;s job management services interact with local resource managers
(LRMs) and other service components of GT 6.0 in order to support job
execution with coordinated file staging.</simpara>
<section id="_gram5_architecture">
<title>GRAM5 Architecture</title>
<simpara>The GRAM5 service architecture consists of several components which work
together to authenticate users, manage jobs, interface with the LRM, and
stage files. These components are:</simpara>
<variablelist>
<varlistentry>
<term>
<emphasis role="strong">Gatekeeper</emphasis>
</term>
<listitem>
<simpara>
    The <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> service provides a network
    interface to the GRAM5 system. It authenticates client identities and
    starts Job Manager processes using the local user account to which the
    client identity is mapped. Typically, one instance of the
    <emphasis role="strong"><literal>globus-gatekeeper</literal></emphasis> process runs to accept network
    connections, and forks a new short-lived process to process each new
    connection.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Job Manager</emphasis>
</term>
<listitem>
<simpara>
    The <emphasis role="strong"><literal>globus-job-manager</literal></emphasis> daemon processes job
    requests and coordinates file transfers. There is one long-lived instance
    of this per user per LRM and one short-lived instance per job.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">Scheduler Event Generator</emphasis>
</term>
<listitem>
<simpara>
    The <emphasis role="strong"><literal>globus-scheduler-event-generator</literal></emphasis> process parses LRM-specific
    data relating to job startup, execution, and termination into an
    LRM-independent data format. There is optionally one instance of this
    program per LRM.
</simpara>
</listitem>
</varlistentry>
<varlistentry>
<term>
<emphasis role="strong">LRM Adapter</emphasis>
</term>
<listitem>
<simpara>
    The LRM adapter provides an interface between the GRAM5 system components
    and the LRM. It provides concrete implementations of the submit, cancel,
    and poll functionality for a particular system&#8217;s LRM and to generate job
    status change events.
</simpara>
</listitem>
</varlistentry>
</variablelist>
</section>
<section id="_external_components_used_by_gram5">
<title>External Components used by GRAM5</title>
<simpara>GRAM5 uses a local resource manager (LRM) to schedule and run jobs on a
compute element. GRAM5 supports several common LRM systems (Condor,
Torque, Oracle GridEngine) and can also be configured to manage jobs
without an LRM.</simpara>
</section>
</section>
</section>
</chapter>
<chapter id="gsicKey" xreflabel="GSI C Security Key Concepts">
<title>GT 6.0 GSI C Security: Key Concepts</title>
<simpara>GSI uses public key cryptography (also known as asymmetric cryptography)
as the basis for its functionality. Many of the terms and concepts used
in this description of GSI come from its use of public key cryptography.</simpara>
<simpara>For a good overview of GSI contained in the Web Services-based
components of GT4, see <ulink url="../../GT4-GSI-Overview.pdf">Globus Toolkit
Version 4 Grid Security Infrastructure: A Standards Perspective</ulink>.
A reference for detailed information about public key cryptography is
available in the book <ulink url="http://www.cacr.math.uwaterloo.ca/hac/">Handbook of
Applied Cryptography</ulink>, by A. Menezes, P. van Oorschot, and S. Vanstone,
CRC Press, 1996.
<ulink url="http://www.cacr.math.uwaterloo.ca/hac/about/chap8.pdf">Chapter 8</ulink> of this
book deals exclusively with public key cryptography.
The primary motivations behind GSI are:</simpara>
<itemizedlist>
<listitem>
<simpara>
The need for secure communication (authenticated and perhaps confidential) between elements of a computational Grid.
</simpara>
</listitem>
<listitem>
<simpara>
The need to support security across organizational boundaries, thus prohibiting a centrally-managed security system.
</simpara>
</listitem>
<listitem>
<simpara>
The need to support "single sign-on" for users of the Grid, including delegation of credentials for computations that involve multiple resources and/or sites.
</simpara>
</listitem>
</itemizedlist>
<section id="gsic-key-concepts">
<title>Conceptual Details</title>
<section id="gsic-key-publickey">
<title>Public Key Cryptography</title>
<simpara>The most important thing to know about public key cryptography is that,
unlike earlier cryptographic systems, it relies not on a single key (a
password or a secret "code"), but on two keys. These keys are numbers
that are mathematically related in such a way that if either key is used
to encrypt a message, the other key must be used to decrypt it. Also
important is the fact that it is next to impossible (with our current
knowledge of mathematics and available computing power) to obtain the
second key from the first one and/or any messages encoded with the first
key.</simpara>
<simpara>By making one of the keys available publicly (a public key) and keeping
the other key private (a private key), a person can prove that he or she
holds the private key simply by encrypting a message. If the message can
be decrypted using the public key, the person must have used the private
key to encrypt the message.</simpara>
<simpara><emphasis role="strong">Important:</emphasis> It is critical that private keys be kept private! Anyone
who knows the private key can easily impersonate the owner.</simpara>
</section>
<section id="gsic-key-digitalsig">
<title>Digital Signatures</title>
<simpara>Using public key cryptography, it is possible to digitally "sign" a
piece of information. Signing information essentially means assuring a
recipient of the information that the information hasn&#8217;t been tampered
with since it left your hands.</simpara>
<simpara>To sign a piece of information, first compute a mathematical hash of the
information. (A hash is a condensed version of the information. The
algorithm used to compute this hash must be known to the recipient of
the information, but it isn&#8217;t a secret.) Using your private key, encrypt
the hash, and attach it to the message. Make sure that the recipient has
your public key.</simpara>
<simpara>To verify that your signed message is authentic, the recipient of the
message will compute the hash of the message using the same hashing
algorithm you used, and will then decrypt the encrypted hash that you
attached to the message. If the newly-computed hash and the decrypted
hash match, then it proves that you signed the message and that the
message has not been changed since you signed it.</simpara>
</section>
<section id="gsic-key-certificates">
<title>Certificates</title>
<simpara>A central concept in GSI authentication is the <emphasis role="strong">certificate</emphasis>. Every
user and service on the Grid is identified via a certificate, which
contains information vital to identifying and authenticating the user or
service.</simpara>
<simpara>A GSI certificate includes four primary pieces of information:</simpara>
<itemizedlist>
<listitem>
<simpara>
A subject name, which identifies the person or object that the certificate represents.
</simpara>
</listitem>
<listitem>
<simpara>
The public key belonging to the subject.
</simpara>
</listitem>
<listitem>
<simpara>
The identity of a Certificate Authority (CA) that has signed the certificate to certify that the public key and the identity both belong to the subject.
</simpara>
</listitem>
<listitem>
<simpara>
The digital signature of the named CA.
</simpara>
</listitem>
</itemizedlist>
<simpara>Note that a third party (a CA) is used to certify the link between the
public key and the subject in the certificate. In order to trust the
certificate and its contents, the CA&#8217;s certificate must be trusted. The
link between the CA and its certificate must be established via some
non-cryptographic means, or else the system is not trustworthy.</simpara>
<simpara>GSI certificates are encoded in the X.509 certificate format, a standard
data format for certificates established by the Internet Engineering
Task Force (IETF). These certificates can be shared with other public
key-based software, including commercial web browsers from Microsoft and
Netscape.</simpara>
</section>
<section id="gsic-key-mutualauthentication">
<title>Mutual Authentication</title>
<simpara>If two parties have certificates, and if both parties trust the CAs that
signed each other&#8217;s certificates, then the two parties can prove to each
other that they are who they say they are. This is known as <emphasis role="strong">mutual
authentication</emphasis>. GSI uses the Secure Sockets Layer (SSL) for its mutual
authentication protocol, which is described
<ulink url="#gsic-key-delegation">below</ulink>. (SSL is also known by a new, IETF
standard name: Transport Layer Security, or TLS.)</simpara>
<simpara>Before mutual authentication can occur, the parties involved must first
trust the CAs that signed each other&#8217;s certificates. In practice, this
means that they must have copies of the CAs' certificates&#8212;which contain
the CAs' public keys&#8212;and that they must trust that these certificates
really belong to the CAs.</simpara>
<simpara>To mutually authenticate, the first person (<emphasis role="strong">A</emphasis>) establishes a
connection to the second person (<emphasis role="strong">B</emphasis>).</simpara>
<simpara>To start the authentication process, <emphasis role="strong">A</emphasis> gives <emphasis role="strong">B</emphasis> his certificate.</simpara>
<simpara>The certificate tells <emphasis role="strong">B</emphasis> who <emphasis role="strong">A</emphasis> is claiming to be (the identity),
what <emphasis role="strong">A</emphasis>'s public key is, and what CA is being used to certify the
certificate.</simpara>
<simpara><emphasis role="strong">B</emphasis> will first make sure that the certificate is valid by checking the
CA&#8217;s digital signature to make sure that the CA actually signed the
certificate and that the certificate hasn&#8217;t been tampered with. (This is
where <emphasis role="strong">B</emphasis> must trust the CA that signed <emphasis role="strong">A</emphasis>'s certificate.)</simpara>
<simpara>Once <emphasis role="strong">B</emphasis> has checked out <emphasis role="strong">A</emphasis>'s certificate, <emphasis role="strong">B</emphasis> must make sure
that <emphasis role="strong">A</emphasis> really is the person identified in the certificate.</simpara>
<simpara><emphasis role="strong">B</emphasis> generates a random message and sends it to <emphasis role="strong">A</emphasis>, asking <emphasis role="strong">A</emphasis> to
encrypt it.</simpara>
<simpara><emphasis role="strong">A</emphasis> encrypts the message using his private key, and sends it back to
<emphasis role="strong">B</emphasis>.</simpara>
<simpara><emphasis role="strong">B</emphasis> decrypts the message using <emphasis role="strong">A</emphasis>'s public key.</simpara>
<simpara>If this results in the original random message, then <emphasis role="strong">B</emphasis> knows that
<emphasis role="strong">A</emphasis> is who he says he is.</simpara>
<simpara>Now that <emphasis role="strong">B</emphasis> trusts <emphasis role="strong">A</emphasis>'s identity, the same operation must happen
in reverse.</simpara>
<simpara><emphasis role="strong">B</emphasis> sends <emphasis role="strong">A</emphasis> her certificate, <emphasis role="strong">A</emphasis> validates the certificate and
sends a challenge message to be encrypted.</simpara>
<simpara><emphasis role="strong">B</emphasis> encrypts the message and sends it back to <emphasis role="strong">A</emphasis>, and <emphasis role="strong">A</emphasis>
decrypts it and compares it with the original.</simpara>
<simpara>If it matches, then <emphasis role="strong">A</emphasis> knows that <emphasis role="strong">B</emphasis> is who she says she is.</simpara>
<simpara>At this point, <emphasis role="strong">A</emphasis> and <emphasis role="strong">B</emphasis> have established a connection to each
other and are certain that they know each others' identities.</simpara>
</section>
<section id="gsic-key-confcommunication">
<title>Confidential Communication</title>
<simpara>By default, GSI does not establish confidential (encrypted)
communication between parties. Once mutual authentication is performed,
GSI gets out of the way so that communication can occur without the
overhead of constant encryption and decryption.</simpara>
<simpara>GSI can easily be used to establish a shared key for encryption if
confidential communication is desired. Recently relaxed United States
export laws now allow us to include encrypted communication as a
standard optional feature of GSI.</simpara>
<simpara>A related security feature is communication integrity. Integrity means
that an eavesdropper may be able to read communication between two
parties but is not able to modify the communication in any way. GSI
provides communication integrity by default. (It can be turned off if
desired). Communication integrity introduces some overhead in
communication, but not as large an overhead as encryption.</simpara>
</section>
<section id="gsic-key-securingprivatekeys">
<title>Securing Private Keys</title>
<simpara>The core GSI software provided by the Globus Toolkit expects the user&#8217;s
private key to be stored in a file in the local computer&#8217;s storage. To
prevent other users of the computer from stealing the private key, the
file that contains the key is encrypted via a password (also known as a
passphrase). To use GSI, the user must enter the passphrase required to
decrypt the file containing their private key.</simpara>
<simpara>We have also prototyped the use of cryptographic smartcards in
conjunction with GSI. This allows users to store their private key on a
smartcard rather than in a file system, making it still more difficult
for others to gain access to the key.</simpara>
</section>
<section id="gsic-key-delegation">
<title>Delegation, Single Sign-On and Proxy Certificates</title>
<simpara>GSI provides a delegation capability: an extension of the standard SSL
protocol which reduces the number of times the user must enter his
passphrase. If a Grid computation requires that several Grid resources
be used (each requiring mutual authentication), or if there is a need to
have agents (local or remote) requesting services on behalf of a user,
the need to re-enter the user&#8217;s passphrase can be avoided by creating a
<emphasis role="strong">proxy</emphasis>.</simpara>
<simpara>A proxy consists of a new certificate and a private key. The key pair
that is used for the proxy, i.e. the public key embedded in the
certificate and the private key, may either be regenerated for each
proxy or obtained by other means. The new certificate contains the
owner&#8217;s identity, modified slightly to indicate that it is a proxy. The
new certificate is signed by the owner, rather than a CA. (See diagram
below.) The certificate also includes a time notation after which the
proxy should no longer be accepted by others. Proxies have limited
lifetimes.</simpara>
<informalfigure>
<mediaobject>
  <imageobject>
  <imagedata fileref="gssapi1.gif" width="75%" scalefit="1" align="center"/>
  </imageobject>
  <textobject><phrase>gssapi1.gif</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The proxy&#8217;s private key must be kept secure, but because the proxy isn&#8217;t
valid for very long, it doesn&#8217;t have to kept quite as secure as the
owner&#8217;s private key. It is thus possible to store the proxy&#8217;s private
key in a local storage system without being encrypted, as long as the
permissions on the file prevent anyone else from looking at them easily.
Once a proxy is created and stored, the user can use the proxy
certificate and private key for mutual authentication without entering a
password.</simpara>
<simpara>When proxies are used, the mutual authentication process differs
slightly. The remote party receives not only the proxy&#8217;s certificate
(signed by the owner), but also the owner&#8217;s certificate. During mutual
authentication, the owner&#8217;s public key (obtained from her certificate)
is used to validate the signature on the proxy certificate. The CA&#8217;s
public key is then used to validate the signature on the owner&#8217;s
certificate. This establishes a chain of trust from the CA to the proxy
through the owner.</simpara>
<note>
<simpara>GSI, and software based on it (notably the Globus Toolkit, GSI-SSH, and GridFTP), is currently the only software which supports the delegation extensions to TLS (a.k.a. SSL). The Globus Alliance has worked in the GGF and the IETF to standardize this extension in the form of Proxy Certificates (RFC 3820) [<ulink url="http://www.ietf.org/rfc/rfc3820.txt">http://www.ietf.org/rfc/rfc3820.txt</ulink>].</simpara>
</note>
</section>
</section>
<section id="gsic-key-relateddocs">
<title>Related Documents</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="../../GT4-GSI-Overview.pdf">Globus Toolkit Version 4 Grid Security Infrastructure: A Standards Perspective</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://www.cacr.math.uwaterloo.ca/hac/">Handbook of Applied Cryptography</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
</book>
